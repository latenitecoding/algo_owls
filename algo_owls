#!/usr/bin/env bash
# This script was generated by bashly 1.1.0 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
algo_owls_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls - Use to create, execute, and test solutions to competitive programming problems\n"
    echo

  else
    printf "algo_owls - Use to create, execute, and test solutions to competitive programming problems\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  algo_owls COMMAND\n"
  printf "  algo_owls [COMMAND] --help | -h\n"
  printf "  algo_owls --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Compile target solution from the 'options.solutions_dir' directory\n" "build "
  printf "  %s   Manage the algo_owls config file\n" "config"
  printf "  %s   Format the target solution from the 'options.solutions_dir' directory\n" "fmt   "
  printf "  %s   Create solution file from a template (if desired)\n" "init  "
  printf "  %s   Run target solution against each input file in 'options.test_dir' comparing results to adjacent answers\n" "quest "
  printf "  %s   Run target program\n" "run   "
  printf "  %s   Commits and pushes target solution using git\n" "submit"
  printf "  %s   Wipes all build files from the 'options.target_dir'\n" "wipe  "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
algo_owls_build_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls build - Compile target solution from the 'options.solutions_dir' directory\n"
    echo

  else
    printf "algo_owls build - Compile target solution from the 'options.solutions_dir' directory\n"
    echo

  fi

  printf "Alias: b\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls build SOLUTION [OPTIONS]\n"
  printf "  algo_owls build --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--build_cmd, -x COMMAND"
    printf "    The build command to compile the program\n"
    echo

    # :flag.usage
    printf "  %s\n" "--build_flags, -I FLAGS"
    printf "    The compiler flags to use when compiling the program\n"
    echo

    # :flag.usage
    printf "  %s\n" "--build_out, -o FLAG"
    printf "    The compiler flag to specify the output directory\n"
    echo

    # :flag.usage
    printf "  %s\n" "--build_sources, -s FLAG"
    printf "    The compiler flag to include sources in the build\n"
    echo

    # :flag.usage
    printf "  %s\n" "--ext, -e EXTENSION"
    printf "    The file extension to use for the solution file\n"
    echo

    # :flag.usage
    printf "  %s\n" "--local, -l"
    printf "    Use target solution's local directory in build source\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no_ext, -n"
    printf "    Ignore file extensions when compiling the program\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SOLUTION"
    printf "    The name of the target solution in the 'options.solutions_dir' directory\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  algo_owls build fadingwind\n"
    printf "  algo_owls build streetsahead --ext .java --build_cmd javac --build_out \"-d\n  options.target_dir\" --build_sources \"-cp options.solutions_dir\"\n"
    printf "  algo_owls build restaurantopening --ext .java --build_cmd javac --build_out\n  \"-d options.target_dir\" --build_sources \"-cp ...\" --local\n"
    echo

  fi
}

# :command.usage
algo_owls_config_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls config - Manage the algo_owls config file\n"
    echo

  else
    printf "algo_owls config - Manage the algo_owls config file\n"
    echo

  fi

  printf "Alias: c\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls config COMMAND\n"
  printf "  algo_owls config [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Read a value from the config file\n" "get "
  printf "  %s   Show entire config file\n" "list"
  printf "  %s   Save a value in the config file\n" "set "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
algo_owls_config_get_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls config get - Read a value from the config file\n"
    echo

  else
    printf "algo_owls config get - Read a value from the config file\n"
    echo

  fi

  printf "Alias: g\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls config get KEY...\n"
  printf "  algo_owls config get --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "KEY..."
    printf "    One or more config keys\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  algo_owls config get TODO\n"
    echo

  fi
}

# :command.usage
algo_owls_config_list_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls config list - Show entire config file\n"
    echo

  else
    printf "algo_owls config list - Show entire config file\n"
    echo

  fi

  printf "Alias: l\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls config list\n"
  printf "  algo_owls config list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  algo_owls config list\n"
    echo

  fi
}

# :command.usage
algo_owls_config_set_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls config set - Save a value in the config file\n"
    echo

  else
    printf "algo_owls config set - Save a value in the config file\n"
    echo

  fi

  printf "Alias: s\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls config set ENTRY...\n"
  printf "  algo_owls config set --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "ENTRY..."
    printf "    One or more config key-value pairs\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  algo_owls config set build.cmd=javac\n"
    printf "  algo_owls config set build_flags.encoding=\"--encoding UTF-8\"\n  build_flags.out=\"-d options.target_dir\"\n"
    echo

  fi
}

# :command.usage
algo_owls_fmt_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls fmt - Format the target solution from the 'options.solutions_dir' directory\n"
    echo

  else
    printf "algo_owls fmt - Format the target solution from the 'options.solutions_dir' directory\n"
    echo

  fi

  printf "Alias: f\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls fmt SOLUTION [OPTIONS]\n"
  printf "  algo_owls fmt --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--fmt_cmd, -x COMMAND"
    printf "    The command to format the target solution\n"
    echo

    # :flag.usage
    printf "  %s\n" "--fmt_flags, -I FLAGS"
    printf "    The flags to use when formatting the target solution\n"
    echo

    # :flag.usage
    printf "  %s\n" "--ext, -e EXTENSION"
    printf "    The file extension to use for the solution file\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no_ext, -n"
    printf "    Ignore file extensions when formatting the program\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SOLUTION"
    printf "    The name of the target solution in the 'options.solutions_dir' directory\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  algo_owls fmt fadingwind\n"
    printf "  algo_owls fmt streetsahead --ext .java --fmt_cmd \"java -jar\n  lib/google-java-format.jar\" --fmt_flags \"--replace --skip-javadoc-formatting\"\n"
    echo

  fi
}

# :command.usage
algo_owls_init_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls init - Create solution file from a template (if desired)\n"
    echo

  else
    printf "algo_owls init - Create solution file from a template (if desired)\n"
    echo

  fi

  printf "Alias: i\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls init SOLUTION [OPTIONS]\n"
  printf "  algo_owls init --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--ext, -e EXTENSION"
    printf "    The file extension to use for the solution and template files\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no_ext, -n"
    printf "    Ignore file extensions when initializing the solution file\n"
    echo

    # :flag.usage
    printf "  %s\n" "--template, -t TEMPLATE"
    printf "    The path to the target template relative to the CWD\n"
    echo

    # :flag.usage
    printf "  %s\n" "--touch, -o"
    printf "    Create a blank solution instead of copying from a template file\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SOLUTION"
    printf "    The path to the target solution relative to the 'options.solutions_dir'\n    directory\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  algo_owls init fadingwind\n"
    printf "  algo_owls init streetsahead --ext .java\n"
    printf "  algo_owls init restaurantopening --ext .java --template\n  ./solutions/streetsahead\n"
    printf "  algo_owls init huntthewumpus --touch\n"
    echo

  fi
}

# :command.usage
algo_owls_quest_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls quest - Run target solution against each input file in 'options.test_dir' comparing results to adjacent answers\n"
    echo

  else
    printf "algo_owls quest - Run target solution against each input file in 'options.test_dir' comparing results to adjacent answers\n"
    echo

  fi

  printf "Alias: q\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls quest SOLUTION [OPTIONS]\n"
  printf "  algo_owls quest --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--build, -b"
    printf "    Execute the default build command prior to questing the target program\n"
    echo

    # :flag.usage
    printf "  %s\n" "--ext, -e EXTENSION"
    printf "    The file extension to use for the target solution\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no_build, -d"
    printf "    Ignore the default build command prior to questing the target program\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no_ext, -n"
    printf "    Ignore extensions when questing the target solution\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SOLUTION"
    printf "    The name of the target solution from the 'options.solutions_dir' directory\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  algo_owls quest fadingwind\n"
    printf "  algo_owls quest fadingwind -ext .class\n"
    echo

  fi
}

# :command.usage
algo_owls_run_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls run - Run target program\n"
    echo

  else
    printf "algo_owls run - Run target program\n"
    echo

  fi

  printf "Alias: r\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls run SOLUTION [OPTIONS]\n"
  printf "  algo_owls run --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--build, -b"
    printf "    Execute the default build command prior to running the target program\n"
    echo

    # :flag.usage
    printf "  %s\n" "--ext, -e EXTENSION"
    printf "    The file extension to use for the target program\n"
    echo

    # :flag.usage
    printf "  %s\n" "--local, -l"
    printf "    Use the target program's local directory from 'options.target_dir' in the\n    runtime source\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no_build, -d"
    printf "    Ignore the default build command prior to running the target program\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no_ext, -n"
    printf "    Ignore extensions when executing the target program\n"
    echo

    # :flag.usage
    printf "  %s\n" "--run_cmd, -x COMMAND"
    printf "    The run command to use to execute the program\n"
    echo

    # :flag.usage
    printf "  %s\n" "--run_flags, -I FLAGS"
    printf "    The runtime flags to use when executing the program\n"
    echo

    # :flag.usage
    printf "  %s\n" "--run_sources, -s FLAG"
    printf "    The runtime flag to include sources in the execution\n"
    echo

    # :flag.usage
    printf "  %s\n" "--use_source, -u"
    printf "    Use the target program's local directory from 'options.solutions_dir' in the\n    runtime source\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SOLUTION"
    printf "    The name of the target program from the 'options.solutions_dir' directory\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  algo_owls run fadingwind\n"
    printf "  algo_owls run streetsahead --ext .class --run_cmd java --run_flags\n  \"-XX:+UseSerialGC\" --run_sources \"-cp options.target_dir\"\n"
    printf "  algo_owls run restaurantopening --ext .class --run_cmd java --run_flags\n  \"-XX:+UseSerialGC\" --run_sources \"-cp ...\" --local\n"
    printf "  algo_owls run huntthewumpus --ext .py --run_cmd python3 --use_source\n"
    echo

  fi
}

# :command.usage
algo_owls_submit_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls submit - Commits and pushes target solution using git\n"
    echo

  else
    printf "algo_owls submit - Commits and pushes target solution using git\n"
    echo

  fi

  printf "Alias: s\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls submit SOLUTION [OPTIONS]\n"
  printf "  algo_owls submit --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--branch, -b BRANCH"
    printf "    The branch to commit to\n"
    echo

    # :flag.usage
    printf "  %s\n" "--ext, -e EXTENSION"
    printf "    The file extension to use for the solution\n"
    echo

    # :flag.usage
    printf "  %s\n" "--fmt, -p"
    printf "    Apply default formatting to target solution before committing\n"
    echo

    # :flag.usage
    printf "  %s\n" "--message, -m"
    printf "    Provide custom commit message\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no_ext, -n"
    printf "    Ignore extensions when executing the target solution\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no_fmt, -q"
    printf "    Ignore any formatting of target solution before committing\n"
    echo

    # :flag.usage
    printf "  %s\n" "--remote, -r REMOTE"
    printf "    The remote to push to\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SOLUTION"
    printf "    The name of the target solution from the 'options.solutions_dir' directory\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  algo_owls submit fadingwind\n"
    printf "  algo_owls submit streetsahead --ext .java --branch hotjava --remote origin\n"
    printf "  algo_owls submit restaurantopening --ext .java --fmt\n"
    echo

  fi
}

# :command.usage
algo_owls_wipe_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls wipe - Wipes all build files from the 'options.target_dir'\n"
    echo

  else
    printf "algo_owls wipe - Wipes all build files from the 'options.target_dir'\n"
    echo

  fi

  printf "Alias: w\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls wipe\n"
  printf "  algo_owls wipe --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  algo_owls wipe\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do echo "- \${deps[$k]} = ${deps[$k]}"; done
  fi

}

# :command.user_lib
# src/lib/handle_file_ext.sh
handle_file_ext() {
    local settings_ext="${ini[settings.file_ext]}"
    local settings_no_ext="${ini[settings.no_ext]}"
    local args_ext="${args[--ext]}"
    local args_no_ext="${args[--no_ext]}"

    if [[ -n $args_no_ext && $args_no_ext -eq 1 ]]; then
        echo ""
        return
    fi

    local file_ext="$settings_ext"
    if [[ -n $settings_no_ext && $settings_no_ext == true ]]; then
        file_ext=""
    fi
    if [[ -n $args_ext ]]; then
        file_ext="$args_ext"
    fi
    if [[ -n $file_ext && ${file_ext:0:1} != "." ]]; then
        file_ext=".$file_ext"
    fi

    echo "$file_ext"
    return
}

# src/lib/ini.sh

ini_load() {
  declare -gA ini

  local ini_file="$1"

  local section=""
  local key=""
  local value=""
  local section_regex="^\[(.+)\]"
  local key_regex="^([^ =]+) *= *(.*) *$"
  local comment_regex="^;"

  while IFS= read -r line; do
    if [[ $line =~ $comment_regex ]]; then
      continue
    elif [[ $line =~ $section_regex ]]; then
      section="${BASH_REMATCH[1]}."
    elif [[ $line =~ $key_regex ]]; then
      key="${BASH_REMATCH[1]}"
      value="${BASH_REMATCH[2]}"
      ini["${section}${key}"]="$value"
    fi
  done <"$ini_file"
}

ini_save() {
  declare -gA ini

  local ini_file="$1"

  local current_section=""
  local has_free_keys=false

  rm -f "$ini_file"

  for key in $(ini_keys); do
    [[ $key == *.* ]] && continue
    has_free_keys=true
    value="${ini[$key]}"
    echo "$key = $value" >>"$ini_file"
  done

  [[ "${has_free_keys}" == "true" ]] && echo >>"$ini_file"

  for key in $(ini_keys); do
    [[ $key == *.* ]] || continue
    value="${ini[$key]}"
    IFS="." read -r section_name key_name <<<"$key"

    if [[ "$current_section" != "$section_name" ]]; then
      [[ $current_section ]] && echo >>"$ini_file"
      echo "[$section_name]" >>"$ini_file"
      current_section="$section_name"
    fi

    echo "$key_name = $value" >>"$ini_file"
  done
}

ini_show() {
  declare -gA ini

  for key in $(ini_keys); do
    echo "$key = ${ini[$key]}"
  done
}

ini_keys() {
  declare -gA ini

  local keys=("${!ini[@]}")
  for a in "${keys[@]}"; do echo "$a"; done | sort
}

# :command.command_functions
# :command.function
algo_owls_build_command() {
  # src/build_command.sh
  ini_load .algo_owls.ini

  file_ext="$(handle_file_ext)"

  solution_file="${args[solution]}"
  if [[ -n $file_ext ]]; then
      solution_file="$solution_file$file_ext"
  fi

  target_file="$(find ${ini[options.solutions_dir]} -name $solution_file)"

  if [[ -z $target_file ]]; then
      echo "algo_owls: $solution_file: No such file" 1>&2
      echo "Try using: ./algo_owls init ${args[solution]}" 1>&2
      exit 1
  fi

  build_cmd="${ini[build.cmd]}"
  if [[ -n ${args[--build_cmd]} ]]; then
      build_cmd="${args[--build_cmd]}"
  fi

  if [[ -n ${args[--build_flags]} ]]; then
      build_cmd="$build_cmd ${args[--build_flags]}"
  else
      for key in "${!ini[@]}"; do
          if [[ $key == build_flags.* ]]; then
              build_cmd="$build_cmd ${ini[$key]}"
          fi
      done
  fi

  if [[ -n ${args[--build_out]} ]]; then
      build_cmd="$build_cmd ${args[--build_out]}"
  fi

  if [[ -n ${args[--build_sources]} ]]; then
      build_sources="${args[--build_sources]}"
      if [[ -n ${args[--local]} && ${args[--local]} -eq 1 ]]; then
          target_dir="${target_file%/*}"
          build_sources="${build_sources//.../$target_dir}"
      fi
      build_cmd="$build_cmd $build_sources"
  fi

  for key in "${!ini[@]}"; do
      if [[ $key == options.* ]]; then
          build_cmd="${build_cmd//$key/${ini[$key]}}"
      fi
  done

  build_cmd="$build_cmd $target_file"

  eval $build_cmd

}

# :command.function
algo_owls_config_get_command() {
  # src/config_get_command.sh
  ini_load .algo_owls.ini

  eval "keys=(${args[key]})"

  for idx in "${!keys[@]}"; do
      key="${keys[idx]}"
      value="${ini[$key]}"

      if [[ -n $value ]]; then
          echo "$key = $value"
      else
          echo "algo_owls: $key: No such key" 1>&2
      fi
  done

}

# :command.function
algo_owls_config_list_command() {
  # src/config_list_command.sh
  ini_load .algo_owls.ini
  ini_show

}

# :command.function
algo_owls_config_set_command() {
  # src/config_set_command.sh
  ini_load .algo_owls.ini

  eval "entries=(${args[entry]})"

  for idx in "${!entries[@]}"; do
      entry="${entries[idx]}"
      key="${entry%%=*}"
      value="${entry#*=}"

      if [[ -n $value ]]; then
          ini["$key"]="$value"
      else
          echo "algo_owls: '' is not a valid value" 1>&2
      fi
  done

  ini_save .algo_owls.ini

}

# :command.function
algo_owls_fmt_command() {
  # src/fmt_command.sh
  ini_load .algo_owls.ini

  file_ext="$(handle_file_ext)"

  solution_file="${args[solution]}"
  if [[ -n $file_ext ]]; then
      solution_file="$solution_file$file_ext"
  fi

  target_file="$(find ${ini[options.solutions_dir]} -name $solution_file)"

  if [[ -z $target_file ]]; then
      echo "algo_owls: $solution_file: No such file" 1>&2
      echo "Try using: ./algo_owls init ${args[solution]}" 1>&2
      exit 1
  fi

  fmt_cmd="${ini[fmt.cmd]}"
  if [[ -n ${args[--fmt_cmd]} ]]; then
      fmt_cmd="${args[--fmt_cmd]}"
  fi

  if [[ -n ${args[--fmt_flags]} ]]; then
      fmt_cmd="$fmt_cmd ${args[--fmt_flags]}"
  else
      for key in "${!ini[@]}"; do
          if [[ $key == fmt_flags.* ]]; then
              fmt_cmd="$fmt_cmd ${ini[$key]}"
          fi
      done
  fi

  for key in "${!ini[@]}"; do
      if [[ $key == options.* ]]; then
          fmt_cmd="${fmt_cmd//$key/${ini[$key]}}"
      fi
  done

  fmt_cmd="$fmt_cmd $target_file"

  eval $fmt_cmd

}

# :command.function
algo_owls_init_command() {
  # src/init_command.sh
  ini_load .algo_owls.ini

  file_ext="$(handle_file_ext)"

  solution_file="${ini[options.solutions_dir]}/${args[solution]}"
  if [[ -n $file_ext ]]; then
      solution_file="$solution_file$file_ext"
  fi

  if [[ -n ${args[--touch]} && ${args[--touch]} -eq 1 ]]; then
      mkdir -p ${solution_file%/*}
      touch $solution_file
      exit 0
  fi

  template_file="${ini[options.template_file]}"
  if [[ -n ${args[--template]} ]]; then
      template_file="${args[--template]}"
  fi
  if [[ -n $file_ext ]]; then
      template_file="$template_file$file_ext"
  fi

  if [[ -z $template_file ]]; then
      echo "algo_owls: Cannot use '' as a template file" 1>&2
      echo "Try using: ./algo_owls init --touch $solution_file" 1>&2
      exit 1
  fi

  if [[ ! -f $template_file ]]; then
      echo "algo_owls: $template_file: No such file" 1>&2
      echo "Try using: ./algo_owls init --touch $solution_file" 1>&2
      exit 1
  fi

  mkdir -p ${solution_file%/*}
  cp $template_file $solution_file

}

# :command.function
algo_owls_quest_command() {
  # src/quest_command.sh
  ini_load .algo_owls.ini

  if [[ -z ${args[--no_build]} || ${args[--no_build]} -eq 0 ]]; then
      if [[ ${ini[settings.auto_build]} == true ]]; then
          ./algo_owls build ${args[solution]}
      elif [[ -n ${args[--build]} && ${args[--build]} -eq 1 ]]; then
          ./algo_owls build ${args[solution]}
      fi
  fi

  target_dir="$(find ${ini[options.tests_dir]} -type d -name ${args[solution]})"

  if [[ -z $target_dir ]]; then
      target_dir="${ini[options.tests_dir]}/**/${args[solution]}/"
      echo "algo_owls: $target_dir: No such directory" 1>&2
      target_dir="${ini[options.tests_dir]}/${args[solution]}"
      echo "Try using: mkdir -p $target_dir" 1>&2
      exit 1
  fi

  file_ext="$(handle_file_ext)"

  solution_file="${args[solution]}"
  if [[ -n $file_ext ]]; then
      solution_file="$solution_file$file_ext"
  fi

  run_cmd="./algo_owls run ${args[solution]}"
  if [[ -n ${args[--ext]} ]]; then
      run_cmd="$run_cmd --ext ${args[--ext]}"
  elif [[ -n ${args[--no_ext]} ]]; then
      run_cmd="$run_cmd --no_ext"
  fi

  all_tests_pass=true
  for in_file in $(find $target_dir -name "*.${ini[settings.in_ext]}"); do
      ans_file="${in_file%.*}.${ini[settings.ans_ext]}"
      if diff -u --suppress-common-lines --label $ans_file --label $solution_file --strip-trailing-cr -d --speed-large-files --color $ans_file <(eval $run_cmd < $in_file); then
          echo -e "\033[0;32m$in_file aye!\033[0m"
      else
          echo -e "\033[0;31m$in_file nay!\033[0m"
          all_tests_pass=false
      fi
  done

  echo ""

  if [[ $all_tests_pass == true ]]; then
      echo -e "\033[0;32m$solution_file passes!\033[0m"
  else
      echo -e "\033[0;31m$solution_file vetoed!\033[0m"
  fi

}

# :command.function
algo_owls_run_command() {
  # src/run_command.sh
  ini_load .algo_owls.ini

  if [[ -z ${args[--no_build]} || ${args[--no_build]} -eq 0 ]]; then
      if [[ ${ini[settings.auto_build]} == true ]]; then
          ./algo_owls build ${args[solution]}
      elif [[ -n ${args[--build]} && ${args[--build]} -eq 1 ]]; then
          ./algo_owls build ${args[solution]}
      fi
  fi

  file_ext="$(handle_file_ext)"

  solution_file="${args[solution]}"
  if [[ -n $file_ext && -n ${args[--ext]} ]]; then
      solution_file="$solution_file$file_ext"
  elif [[ -z ${args[--no_ext]} || ${args[--no_ext]} -eq 0 ]]; then
      if [[ -n ${ini[run.file_ext]} ]]; then
          file_ext="${ini[run.file_ext]}"
          if [[ -n $file_ext && ${file_ext:0:1} != "." ]]; then
              file_ext=".$file_ext"
          fi
      fi
      if [[ -n $file_ext && ${ini[run.no_ext]} == false ]]; then
          solution_file="$solution_file$file_ext"
      fi
  fi

  if [[ -n ${args[--use_source]} && ${args[--use_source]} -eq 1 ]]; then
      target_file="$(find ${ini[options.solutions_dir]} -name $solution_file)"
  else
      target_file="$(find ${ini[options.target_dir]} -name $solution_file)"
  fi

  if [[ -z $target_file ]]; then
      echo "algo_owls: $solution_file: No such file" 1>&2
      echo "Try using: ./algo_owls init ${args[solution]}" 1>&2
      exit 1
  fi

  run_cmd="${ini[run.cmd]}"
  if [[ -n ${args[--run_cmd]} ]]; then
      run_cmd="${args[--run_cmd]}"
  fi

  if [[ -n ${args[--run_flags]} ]]; then
      run_cmd="$run_cmd ${args[--run_flags]}"
  else
      for key in "${!ini[@]}"; do
          if [[ $key == run_flags.* ]]; then
              run_cmd="$run_cmd ${ini[$key]}"
          fi
      done
  fi

  if [[ -n ${args[--run_sources]} ]]; then
      run_sources="${args[--run_sources]}"
      if [[ -n ${args[--local]} && ${args[--local]} -eq 1 ]]; then
          target_dir="${target_file%/*}"
          run_sources="${run_sources//.../$target_dir}"
      elif [[ -n ${args[--use_source]} && ${args[--use_source]} -eq 1 ]]; then
          target_dir="${target_file%/*}"
          run_sources="${run_sources//.../$target_dir}"
      fi
      run_cmd="$run_cmd $run_sources"
  fi

  for key in "${!ini[@]}"; do
      if [[ $key == options.* ]]; then
          run_cmd="${run_cmd//$key/${ini[$key]}}"
      fi
  done

  run_cmd="$run_cmd $target_file"

  eval $run_cmd

}

# :command.function
algo_owls_submit_command() {
  # src/submit_command.sh
  ini_load .algo_owls.ini

  file_ext="$(handle_file_ext)"

  solution_file="${args[solution]}"
  if [[ -n $file_ext ]]; then
      solution_file="$solution_file$file_ext"
  fi

  target_file="$(find ${ini[options.solutions_dir]} -name $solution_file)"

  if [[ -z $target_file ]]; then
      echo "algo_owls: $solution_file: No such file" 1>&2
      echo "Try using: ./algo_owls init ${args[soluton]}" 1>&2
      exit 1
  fi

  if [[ -z ${args[--no_fmt]} || ${args[--no_fmt]} -eq 0 ]]; then
      if [[ ${ini[settings.auto_fmt]} == true ]]; then
          ./algo_owls fmt ${args[solution]}
      elif [[ -n ${args[--fmt]} && ${args[--fmt]} -eq 1 ]]; then
          ./algo_owls fmt ${args[solution]}
      fi
  fi

  git add $target_file

  commit_message="completes ${args[solution]}"
  if [[ -n ${args[--message]} ]]; then
      commit_message="${args[--message]}"
  fi

  git commit -m $commit_message

  branch="${ini[git.branch]}"
  if [[ -n ${args[--branch]} ]]; then
      branch="${args[--branch]}"
  fi

  remote="${ini[git.remote]}"
  if [[ -n ${args[--remote]} ]]; then
      remote="${args[--remote]}"
  fi

  git push $remote $branch

}

# :command.function
algo_owls_wipe_command() {
  # src/wipe_command.sh
  ini_load .algo_owls.ini

  rm -r ${ini[options.target_dir]}/*

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        algo_owls_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    build | b)
      action="build"
      shift
      algo_owls_build_parse_requirements "$@"
      shift $#
      ;;

    config | c)
      action="config"
      shift
      algo_owls_config_parse_requirements "$@"
      shift $#
      ;;

    fmt | f)
      action="fmt"
      shift
      algo_owls_fmt_parse_requirements "$@"
      shift $#
      ;;

    init | i)
      action="init"
      shift
      algo_owls_init_parse_requirements "$@"
      shift $#
      ;;

    quest | q)
      action="quest"
      shift
      algo_owls_quest_parse_requirements "$@"
      shift $#
      ;;

    run | r)
      action="run"
      shift
      algo_owls_run_parse_requirements "$@"
      shift $#
      ;;

    submit | s)
      action="submit"
      shift
      algo_owls_submit_parse_requirements "$@"
      shift $#
      ;;

    wipe | w)
      action="wipe"
      shift
      algo_owls_wipe_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      algo_owls_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
algo_owls_build_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_build_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="build"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --build_cmd | -x)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--build_cmd']="$2"
          shift
          shift
        else
          printf "%s\n" "--build_cmd requires an argument: --build_cmd, -x COMMAND" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --build_flags | -I)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--build_flags']="$2"
          shift
          shift
        else
          printf "%s\n" "--build_flags requires an argument: --build_flags, -I FLAGS" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --build_out | -o)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--build_out']="$2"
          shift
          shift
        else
          printf "%s\n" "--build_out requires an argument: --build_out, -o FLAG" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --build_sources | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--build_sources']="$2"
          shift
          shift
        else
          printf "%s\n" "--build_sources requires an argument: --build_sources, -s FLAG" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --ext | -e)
        # :flag.conflicts
        if [[ -n "${args['--no_ext']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--no_ext" >&2
          exit 1
        fi

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--ext']="$2"
          shift
          shift
        else
          printf "%s\n" "--ext requires an argument: --ext, -e EXTENSION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --local | -l)

        # :flag.case_no_arg
        args['--local']=1
        shift
        ;;

      # :flag.case
      --no_ext | -n)
        # :flag.conflicts
        if [[ -n "${args['--ext']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--ext" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--no_ext']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['solution']+x} ]]; then

          args['solution']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['solution']+x} ]]; then
    printf "missing required argument: SOLUTION\nusage: algo_owls build SOLUTION [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
algo_owls_config_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_config_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    get | g)
      action="get"
      shift
      algo_owls_config_get_parse_requirements "$@"
      shift $#
      ;;

    list | l)
      action="list"
      shift
      algo_owls_config_list_parse_requirements "$@"
      shift $#
      ;;

    set | s)
      action="set"
      shift
      algo_owls_config_set_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      algo_owls_config_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
algo_owls_config_get_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_config_get_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="config get"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_repeatable

        if [[ -z ${args['key']+x} ]]; then
          args['key']="\"$1\""
          shift
        else
          args['key']="${args[key]} \"$1\""
          shift
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['key']+x} ]]; then
    printf "missing required argument: KEY\nusage: algo_owls config get KEY...\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
algo_owls_config_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_config_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="config list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
algo_owls_config_set_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_config_set_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="config set"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_repeatable

        if [[ -z ${args['entry']+x} ]]; then
          args['entry']="\"$1\""
          shift
        else
          args['entry']="${args[entry]} \"$1\""
          shift
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['entry']+x} ]]; then
    printf "missing required argument: ENTRY\nusage: algo_owls config set ENTRY...\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
algo_owls_fmt_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_fmt_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="fmt"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --fmt_cmd | -x)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--fmt_cmd']="$2"
          shift
          shift
        else
          printf "%s\n" "--fmt_cmd requires an argument: --fmt_cmd, -x COMMAND" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --fmt_flags | -I)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--fmt_flags']="$2"
          shift
          shift
        else
          printf "%s\n" "--fmt_flags requires an argument: --fmt_flags, -I FLAGS" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --ext | -e)
        # :flag.conflicts
        if [[ -n "${args['--no_ext']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--no_ext" >&2
          exit 1
        fi

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--ext']="$2"
          shift
          shift
        else
          printf "%s\n" "--ext requires an argument: --ext, -e EXTENSION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --no_ext | -n)
        # :flag.conflicts
        if [[ -n "${args['--ext']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--ext" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--no_ext']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['solution']+x} ]]; then

          args['solution']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['solution']+x} ]]; then
    printf "missing required argument: SOLUTION\nusage: algo_owls fmt SOLUTION [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
algo_owls_init_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_init_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="init"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --ext | -e)
        # :flag.conflicts
        if [[ -n "${args['--no_ext']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--no_ext" >&2
          exit 1
        fi

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--ext']="$2"
          shift
          shift
        else
          printf "%s\n" "--ext requires an argument: --ext, -e EXTENSION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --no_ext | -n)
        # :flag.conflicts
        if [[ -n "${args['--ext']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--ext" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--no_ext']=1
        shift
        ;;

      # :flag.case
      --template | -t)
        # :flag.conflicts
        if [[ -n "${args['--touch']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--touch" >&2
          exit 1
        fi

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--template']="$2"
          shift
          shift
        else
          printf "%s\n" "--template requires an argument: --template, -t TEMPLATE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --touch | -o)
        # :flag.conflicts
        if [[ -n "${args['--template']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--template" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--touch']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['solution']+x} ]]; then

          args['solution']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['solution']+x} ]]; then
    printf "missing required argument: SOLUTION\nusage: algo_owls init SOLUTION [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
algo_owls_quest_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_quest_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="quest"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --build | -b)
        # :flag.conflicts
        if [[ -n "${args['--no_build']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--no_build" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--build']=1
        shift
        ;;

      # :flag.case
      --ext | -e)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--ext']="$2"
          shift
          shift
        else
          printf "%s\n" "--ext requires an argument: --ext, -e EXTENSION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --no_build | -d)
        # :flag.conflicts
        if [[ -n "${args['--build']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--build" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--no_build']=1
        shift
        ;;

      # :flag.case
      --no_ext | -n)
        # :flag.conflicts
        if [[ -n "${args['--no_ext']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--no_ext" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--no_ext']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['solution']+x} ]]; then

          args['solution']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['solution']+x} ]]; then
    printf "missing required argument: SOLUTION\nusage: algo_owls quest SOLUTION [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
algo_owls_run_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_run_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="run"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --build | -b)
        # :flag.conflicts
        if [[ -n "${args['--no_build']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--no_build" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--build']=1
        shift
        ;;

      # :flag.case
      --ext | -e)
        # :flag.conflicts
        if [[ -n "${args['--no_ext']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--no_ext" >&2
          exit 1
        fi

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--ext']="$2"
          shift
          shift
        else
          printf "%s\n" "--ext requires an argument: --ext, -e EXTENSION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --local | -l)
        # :flag.conflicts
        if [[ -n "${args['--use_source']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--use_source" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--local']=1
        shift
        ;;

      # :flag.case
      --no_build | -d)
        # :flag.conflicts
        if [[ -n "${args['--build']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--build" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--no_build']=1
        shift
        ;;

      # :flag.case
      --no_ext | -n)
        # :flag.conflicts
        if [[ -n "${args['--ext']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--ext" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--no_ext']=1
        shift
        ;;

      # :flag.case
      --run_cmd | -x)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--run_cmd']="$2"
          shift
          shift
        else
          printf "%s\n" "--run_cmd requires an argument: --run_cmd, -x COMMAND" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --run_flags | -I)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--run_flags']="$2"
          shift
          shift
        else
          printf "%s\n" "--run_flags requires an argument: --run_flags, -I FLAGS" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --run_sources | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--run_sources']="$2"
          shift
          shift
        else
          printf "%s\n" "--run_sources requires an argument: --run_sources, -s FLAG" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --use_source | -u)
        # :flag.conflicts
        if [[ -n "${args['--local']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--local" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--use_source']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['solution']+x} ]]; then

          args['solution']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['solution']+x} ]]; then
    printf "missing required argument: SOLUTION\nusage: algo_owls run SOLUTION [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
algo_owls_submit_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_submit_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="submit"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --branch | -b)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--branch']="$2"
          shift
          shift
        else
          printf "%s\n" "--branch requires an argument: --branch, -b BRANCH" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --ext | -e)
        # :flag.conflicts
        if [[ -n "${args['--no_ext']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--no_ext" >&2
          exit 1
        fi

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--ext']="$2"
          shift
          shift
        else
          printf "%s\n" "--ext requires an argument: --ext, -e EXTENSION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --fmt | -p)
        # :flag.conflicts
        if [[ -n "${args['--no_fmt']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--no_fmt" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--fmt']=1
        shift
        ;;

      # :flag.case
      --message | -m)

        # :flag.case_no_arg
        args['--message']=1
        shift
        ;;

      # :flag.case
      --no_ext | -n)
        # :flag.conflicts
        if [[ -n "${args['--ext']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--ext" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--no_ext']=1
        shift
        ;;

      # :flag.case
      --no_fmt | -q)
        # :flag.conflicts
        if [[ -n "${args['--fmt']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--fmt" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--no_fmt']=1
        shift
        ;;

      # :flag.case
      --remote | -r)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--remote']="$2"
          shift
          shift
        else
          printf "%s\n" "--remote requires an argument: --remote, -r REMOTE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['solution']+x} ]]; then

          args['solution']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['solution']+x} ]]; then
    printf "missing required argument: SOLUTION\nusage: algo_owls submit SOLUTION [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
algo_owls_wipe_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_wipe_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="wipe"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  version="0.2.0"
  long_usage=''
  set -e

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "build") algo_owls_build_command ;;
    "config") algo_owls_config_command ;;
    "config get") algo_owls_config_get_command ;;
    "config list") algo_owls_config_list_command ;;
    "config set") algo_owls_config_set_command ;;
    "fmt") algo_owls_fmt_command ;;
    "init") algo_owls_init_command ;;
    "quest") algo_owls_quest_command ;;
    "run") algo_owls_run_command ;;
    "submit") algo_owls_submit_command ;;
    "wipe") algo_owls_wipe_command ;;
  esac
}

initialize
run "$@"
