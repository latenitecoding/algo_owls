#!/usr/bin/env bash
# This script was generated by bashly 1.1.0 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
algo_owls_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls - Use to create, execute, and test solutions to competitive programming problems\n"
    echo

  else
    printf "algo_owls - Use to create, execute, and test solutions to competitive programming problems\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  algo_owls COMMAND\n"
  printf "  algo_owls [COMMAND] --help | -h\n"
  printf "  algo_owls --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Compile target solution from the 'options.solutions_dir' directory\n" "build "
  printf "  %s   Manage the algo_owls config file\n" "config"
  printf "  %s   Format the target solution from the 'options.solutions_dir' directory\n" "fmt   "
  printf "  %s   Create solution file from a template (if desired)\n" "init  "
  printf "  %s   Run target solution against each input file in 'options.test_dir' comparing results to adjacent answers\n" "quest "
  printf "  %s   Run target solution\n" "run   "
  printf "  %s   Commits and pushes target solution using git\n" "submit"
  printf "  %s   Wipes all build files from the 'options.target_dir'\n" "wipe  "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
algo_owls_build_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls build - Compile target solution from the 'options.solutions_dir' directory\n"
    echo

  else
    printf "algo_owls build - Compile target solution from the 'options.solutions_dir' directory\n"
    echo

  fi

  printf "Alias: b\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls build SOLUTION [OPTIONS]\n"
  printf "  algo_owls build --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--build_cmd, -x COMMAND"
    printf "    The build command to compile the program\n"
    echo

    # :flag.usage
    printf "  %s\n" "--build_flags, -I FLAGS"
    printf "    The compiler flags to use when compiling the program\n"
    echo

    # :flag.usage
    printf "  %s\n" "--build_out, -o FLAG"
    printf "    The compiler flag to specify the output directory (can pattern match on\n    'options.target_dir')\n"
    echo

    # :flag.usage
    printf "  %s\n" "--build_sources, -s FLAG"
    printf "    The compiler flag to include sources in the build (can pattern match on\n    'options.solutions_dir')\n"
    echo

    # :flag.usage
    printf "  %s\n" "--ext, -e EXTENSION"
    printf "    The file extension to use for the solution file\n"
    echo

    # :flag.usage
    printf "  %s\n" "--local, -l"
    printf "    Use the target solution directory as the build source\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no_ext, -n"
    printf "    Ignore file extensions when compiling the program\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SOLUTION"
    printf "    The name of the target solution in the 'options.solutions_dir' directory\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  algo_owls build TODO\n"
    echo

  fi
}

# :command.usage
algo_owls_config_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls config - Manage the algo_owls config file\n"
    echo

  else
    printf "algo_owls config - Manage the algo_owls config file\n"
    echo

  fi

  printf "Alias: c\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls config COMMAND\n"
  printf "  algo_owls config [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Read a value from the config file\n" "get "
  printf "  %s   Show entire config file\n" "list"
  printf "  %s   Save a value in the config file\n" "set "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
algo_owls_config_get_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls config get - Read a value from the config file\n"
    echo

  else
    printf "algo_owls config get - Read a value from the config file\n"
    echo

  fi

  printf "Alias: g\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls config get KEY\n"
  printf "  algo_owls config get --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "KEY"
    printf "    Config key\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  algo_owls config get TODO\n"
    echo

  fi
}

# :command.usage
algo_owls_config_list_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls config list - Show entire config file\n"
    echo

  else
    printf "algo_owls config list - Show entire config file\n"
    echo

  fi

  printf "Alias: l\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls config list\n"
  printf "  algo_owls config list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  algo_owls config list\n"
    echo

  fi
}

# :command.usage
algo_owls_config_set_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls config set - Save a value in the config file\n"
    echo

  else
    printf "algo_owls config set - Save a value in the config file\n"
    echo

  fi

  printf "Alias: s\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls config set KEY VALUE\n"
  printf "  algo_owls config set --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "KEY"
    printf "    Config key\n"
    echo

    # :argument.usage
    printf "  %s\n" "VALUE"
    printf "    Config value\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  algo_owls config set TODO\n"
    echo

  fi
}

# :command.usage
algo_owls_fmt_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls fmt - Format the target solution from the 'options.solutions_dir' directory\n"
    echo

  else
    printf "algo_owls fmt - Format the target solution from the 'options.solutions_dir' directory\n"
    echo

  fi

  printf "Alias: f\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls fmt SOLUTION [OPTIONS]\n"
  printf "  algo_owls fmt --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--fmt_cmd, -x COMMAND"
    printf "    The command to format the target solution\n"
    echo

    # :flag.usage
    printf "  %s\n" "--fmt_flags, -I FLAGS"
    printf "    The flags to use when formatting the program\n"
    echo

    # :flag.usage
    printf "  %s\n" "--ext, -e EXTENSION"
    printf "    The file extension to use for the solution file\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no_ext, -n"
    printf "    Ignore file extensions when formatting the program\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SOLUTION"
    printf "    The name of the target solution in the 'options.solutions_dir' directory\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  algo_owls fmt TODO\n"
    echo

  fi
}

# :command.usage
algo_owls_init_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls init - Create solution file from a template (if desired)\n"
    echo

  else
    printf "algo_owls init - Create solution file from a template (if desired)\n"
    echo

  fi

  printf "Alias: i\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls init SOLUTION [OPTIONS]\n"
  printf "  algo_owls init --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--ext, -e EXTENSION"
    printf "    The file extension to use for the solution and template files\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no_ext, -n"
    printf "    Ignore file extensions when initializing the solution file\n"
    echo

    # :flag.usage
    printf "  %s\n" "--template, -t TEMPLATE"
    printf "    The path to the target template relative to the CWD\n"
    echo

    # :flag.usage
    printf "  %s\n" "--touch, -o"
    printf "    Create a blank solution instead of copying from a template file\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SOLUTION"
    printf "    The path to the target solution relative to the 'options.solutions_dir'\n    directory\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  algo_owls init TODO\n"
    echo

  fi
}

# :command.usage
algo_owls_quest_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls quest - Run target solution against each input file in 'options.test_dir' comparing results to adjacent answers\n"
    echo

  else
    printf "algo_owls quest - Run target solution against each input file in 'options.test_dir' comparing results to adjacent answers\n"
    echo

  fi

  printf "Alias: q\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls quest SOLUTION [OPTIONS]\n"
  printf "  algo_owls quest --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--ext, -e EXTENSION"
    printf "    The file extension to use for the target solution\n"
    echo

    # :flag.usage
    printf "  %s\n" "--local, -l"
    printf "    Use the 'options.target_dir' directory as the runtime source\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no_ext, -n"
    printf "    Ignore extensions when executing the target solution\n"
    echo

    # :flag.usage
    printf "  %s\n" "--use_source, -u"
    printf "    Use the 'options.solutions_dir' directory as the runtime source\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SOLUTION"
    printf "    The name of the target solution from the 'options.solutions_dir' directory\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  algo_owls quest TODO\n"
    echo

  fi
}

# :command.usage
algo_owls_run_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls run - Run target solution\n"
    echo

  else
    printf "algo_owls run - Run target solution\n"
    echo

  fi

  printf "Alias: r\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls run SOLUTION [OPTIONS]\n"
  printf "  algo_owls run --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--build, -b"
    printf "    Execute the default build command prior to running the target solution\n"
    echo

    # :flag.usage
    printf "  %s\n" "--ext, -e EXTENSION"
    printf "    The file extension to use for the solution\n"
    echo

    # :flag.usage
    printf "  %s\n" "--local, -l"
    printf "    Use the 'options.target_dir' directory as the runtime source\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no_ext, -n"
    printf "    Ignore extensions when executing the target solution\n"
    echo

    # :flag.usage
    printf "  %s\n" "--run_cmd, -x COMMAND"
    printf "    The run command to use to execute the solution\n"
    echo

    # :flag.usage
    printf "  %s\n" "--run_flags, -I FLAGS"
    printf "    The runtime flags to use when executing the program\n"
    echo

    # :flag.usage
    printf "  %s\n" "--run_sources, -s FLAG"
    printf "    The runtime flag to include sources in the execution (can pattern match on\n    'options.target_dir')\n"
    echo

    # :flag.usage
    printf "  %s\n" "--use_source, -u"
    printf "    Use the 'options.solutions_dir' directory as the runtime source\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SOLUTION"
    printf "    The name of the target solution from the 'options.solutions_dir' directory\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  algo_owls run TODO\n"
    echo

  fi
}

# :command.usage
algo_owls_submit_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls submit - Commits and pushes target solution using git\n"
    echo

  else
    printf "algo_owls submit - Commits and pushes target solution using git\n"
    echo

  fi

  printf "Alias: s\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls submit SOLUTION [OPTIONS]\n"
  printf "  algo_owls submit --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--branch, -b BRANCH"
    printf "    The branch to commit to\n"
    echo

    # :flag.usage
    printf "  %s\n" "--ext, -e EXTENSION"
    printf "    The file extension to use for the solution\n"
    echo

    # :flag.usage
    printf "  %s\n" "--fmt, -p"
    printf "    Apply default formatting to target solution before committing\n"
    echo

    # :flag.usage
    printf "  %s\n" "--message, -m"
    printf "    Provide custom commit message\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no_ext, -n"
    printf "    Ignore extensions when executing the target solution\n"
    echo

    # :flag.usage
    printf "  %s\n" "--remote, -r REMOTE"
    printf "    The remote to push to\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SOLUTION"
    printf "    The name of the target solution from the 'options.solutions_dir' directory\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  algo_owls submit TODO\n"
    echo

  fi
}

# :command.usage
algo_owls_wipe_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls wipe - Wipes all build files from the 'options.target_dir'\n"
    echo

  else
    printf "algo_owls wipe - Wipes all build files from the 'options.target_dir'\n"
    echo

  fi

  printf "Alias: w\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls wipe\n"
  printf "  algo_owls wipe --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  algo_owls wipe TODO\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do echo "- \${deps[$k]} = ${deps[$k]}"; done
  fi

}

# :command.user_lib
# src/lib/ini.sh

ini_load() {
  declare -gA ini

  local ini_file="$1"

  local section=""
  local key=""
  local value=""
  local section_regex="^\[(.+)\]"
  local key_regex="^([^ =]+) *= *(.*) *$"
  local comment_regex="^;"

  while IFS= read -r line; do
    if [[ $line =~ $comment_regex ]]; then
      continue
    elif [[ $line =~ $section_regex ]]; then
      section="${BASH_REMATCH[1]}."
    elif [[ $line =~ $key_regex ]]; then
      key="${BASH_REMATCH[1]}"
      value="${BASH_REMATCH[2]}"
      ini["${section}${key}"]="$value"
    fi
  done <"$ini_file"
}

ini_save() {
  declare -gA ini

  local ini_file="$1"

  local current_section=""
  local has_free_keys=false

  rm -f "$ini_file"

  for key in $(ini_keys); do
    [[ $key == *.* ]] && continue
    has_free_keys=true
    value="${ini[$key]}"
    echo "$key = $value" >>"$ini_file"
  done

  [[ "${has_free_keys}" == "true" ]] && echo >>"$ini_file"

  for key in $(ini_keys); do
    [[ $key == *.* ]] || continue
    value="${ini[$key]}"
    IFS="." read -r section_name key_name <<<"$key"

    if [[ "$current_section" != "$section_name" ]]; then
      [[ $current_section ]] && echo >>"$ini_file"
      echo "[$section_name]" >>"$ini_file"
      current_section="$section_name"
    fi

    echo "$key_name = $value" >>"$ini_file"
  done
}

ini_show() {
  declare -gA ini

  for key in $(ini_keys); do
    echo "$key = ${ini[$key]}"
  done
}

ini_keys() {
  declare -gA ini

  local keys=("${!ini[@]}")
  for a in "${keys[@]}"; do echo "$a"; done | sort
}

# :command.command_functions
# :command.function
algo_owls_build_command() {
  # src/build_command.sh
  EXT="$ALGO_EXT"
  if [[ ! -z ${args[--ext]} ]]; then
      EXT="${args[--ext]}"
  fi
  if [[ ${EXT:0:1} != "." ]]; then
      EXT=".$EXT"
  fi

  SOLUTION="${args[solution]}$EXT"

  TARGET_FILE=$(find $ALGO_SOLUTIONS -name $SOLUTION)

  if [[ -z $TARGET_FILE ]]; then
      echo "algo_owls: $SOLUTION: No such file or directory" 1>&2
      echo "Try using: ./algo_owls init $ALGO_SOLUTIONS/$SOLUTION"
      exit 1
  fi

  BUILD_FLAG="${ALGO_BUILD_FLAG}"
  if [[ ! -z ${args[--build_flag]} ]]; then
      BUILD_FLAG="${args[--build_flag]}"
  fi

  BUILD_CMD="${ALGO_BUILD_CMD}"
  if [[ ! -z ${args[--build_cmd]} ]]; then
      BUILD_CMD="${args[--build_cmd]}"
  fi
  if [[ ! -z $BUILD_FLAG ]]; then
      BUILD_CMD="$BUILD_CMD $BUILD_FLAG $ALGO_TARGET"
  fi
  BUILD_CMD="$BUILD_CMD $TARGET_FILE"

  eval $BUILD_CMD

}

# :command.function
algo_owls_config_get_command() {
  # src/config_get_command.sh
  ini_load .algo_owls.ini

  KEY="${args[key]}"
  VALUE=${ini[$KEY]}

  if [[ -z $VALUE ]]; then
      echo "algo_owls: $KEY: No such key" 1>&2
      exit 1
  fi

  echo "$KEY = $VALUE"

}

# :command.function
algo_owls_config_list_command() {
  # src/config_list_command.sh
  ini_load .algo_owls.ini
  ini_show

}

# :command.function
algo_owls_config_set_command() {
  # src/config_set_command.sh
  ini_load .algo_owls.ini

  KEY="${args[key]}"
  VALUE="${args[value]}"

  ini["$KEY"]="$VALUE"
  ini_save .algo_owls.ini

}

# :command.function
algo_owls_fmt_command() {
  # src/fmt_command.sh
  echo "# this file is located in 'src/fmt_command.sh'"
  echo "# code for 'algo_owls fmt' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
algo_owls_init_command() {
  # src/init_command.sh
  ini_load .algo_owls.ini

  EXT="${ini[options.file_ext]}"
  if [[ ! -z ${args[--ext]} ]]; then
      EXT="${args[--ext]}"
  fi
  if [[ ${EXT:0:1} != "." ]]; then
      EXT=".$EXT"
  fi

  TEMPLATE="${ini[options.template_file]}"
  if [[ ! -z ${args[--template]} ]]; then
      TEMPLATE="${args[--template]}"
  fi

  SOLUTION="${ini[options.solutions_dir]}/${args[solution]}"

  if [[ -z ${args[--no_ext]} || ${args[--no_ext]} == 0 ]]; then
      TEMPLATE="$TEMPLATE$EXT"
      SOLUTION="$SOLUTION$EXT"
  fi

  if [[ ! -z ${args[--touch]} && ${args[--touch]} == 1 ]]; then
      mkdir -p ${SOLUTION%/*}
      touch $SOLUTION
      exit 0
  fi

  if [[ -z $TEMPLATE ]]; then
      echo "algo_owls: Cannot use '' as a template file" 1>&2
      echo "Try using: ./algo_owls init --touch $SOLUTION"
      exit 1
  fi

  if [[ ! -f $TEMPLATE ]]; then
      echo "algo_owls: $TEMPLATE: No such file or directory" 1>&2
      echo "Try using: ./algo_owls init --touch $SOLUTION"
      exit 1
  fi

  mkdir -p ${SOLUTION%/*}
  cp $TEMPLATE $SOLUTION

}

# :command.function
algo_owls_quest_command() {
  # src/quest_command.sh
  echo "# this file is located in 'src/quest_command.sh'"
  echo "# code for 'algo_owls quest' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

}

# :command.function
algo_owls_run_command() {
  # src/run_command.sh
  echo "# this file is located in 'src/run_command.sh'"
  echo "# code for 'algo_owls run' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args

  if [[ ! -z ${args[--build]} && ${args[--build]} == 1 ]]; then
      if [[ ! -z ${args[--ext]} ]]; then
          ./algo_owls build --ext ${args[--ext]} ${args[solution]}
      else
          ./algo_owls build ${args[solution]}
      fi
  fi

  EXT="$ALGO_EXT"
  if [[ ! -z ${args[--ext]} ]]; then
      EXT="${args[--ext]}"
  fi
  if [[ ${EXT:0:1} != "." ]]; then
      EXT=".$EXT"
  fi

  SOLUTION="${args[solution]}"
  if [[ -z ${args[--no_ext]} || ${args[--no_ext]} == 0 ]]; then
      SOLUTION="$SOLUTION$EXT"
  fi

  TARGET_DIR="$ALGO_TARGET"
  if [[ ! -z ${args[--use_source]} && ${args[--use_source]} == 1 ]]; then
      TARGET_DIR="$ALGO_SOLUTIONS"
  fi

  TARGET_FILE=$(find $TARGET_DIR -name $SOLUTION)

  if [[ -z $TARGET_FILE ]]; then
      echo "algo_owls: $SOLUTION: No such file or directory" 1>&2
      echo "Try using: ./algo_owls run --build $SOLUTION"
      exit 1
  fi

  RUN_FLAG="${ALGO_RUN_FLAG}"
  if [[ ! -z ${args[--run_flag]} ]]; then
      RUN_FLAG="${args[--run_flag]}"
  fi

  RUN_CMD="${ALGO_RUN_CMD}"
  if [[ ! -z ${args[--run_cmd]} ]]; then
      RUN_CMD="${args[--run_cmd]}"
  fi
  if [[ ! -z $RUN_FLAG ]]; then
      RUN_CMD="$RUN_CMD $RUN_FLAG $TARGET_DIR"
  fi
  RUN_CMD="$RUN_CMD $TARGET_FILE"

  eval $RUN_CMD

}

# :command.function
algo_owls_submit_command() {
  # src/submit_command.sh
  ini_load .algo_owls.ini

  EXT="${ini[options.file_ext]}"
  if [[ ! -z ${args[--ext]} ]]; then
      EXT="${args[--ext]}"
  fi
  if [[ ${EXT:0:1} != "." ]]; then
      EXT=".$EXT"
  fi

  SOLUTION="${args[solution]}"
  if [[ -z ${args[--no_ext]} || ${args[--no_ext]} == 0 ]]; then
      SOLUTION="$SOLUTION$EXT"
  fi

  TARGET_FILE=$(find ${ini[options.solutions_dir]} -name $SOLUTION)

  if [[ -z $TARGET_FILE ]]; then
      echo "algo_owls: $SOLUTION: No such file or directory" 1>&2
      echo "Try using: ./algo_owls init ${ini[options.solutions_dir]}$SOLUTION"
      exit 1
  fi

  if [[ ! -z ${args[--fmt]} && ${args[--fmt]} == 1 ]]; then
      FLAGS=""
      if [[ ! -z ${args[--ext]} ]]; then
          FLAGS="--ext ${args[--ext]}"
      fi
      if [[ ! -z ${args[--no_ext]} && ${args[--no_ext]} == 1 ]]; then
          FLAGS="--no_ext"
      fi
      if [[ -z $FLAGS ]]; then
          ./algo_owls fmt ${args[solution]}
      else
          ./algo_owls fmt ${args[solution]} $FLAGS
      fi
  fi

  git add $TARGET_FILE

  MESSAGE="completes ${args[solution]}"
  if [[ ! -z ${args[--message]} ]]; then
      MESSAGE="${args[--message]}"
  fi

  git commit -m $MESSAGE

  BRANCH="${ini[options.branch]}"
  if [[ ! -z ${args[--branch]} ]]; then
      BRANCH="${args[--branch]}"
  fi

  REMOTE="${ini[options.remote]}"
  if [[ ! -z ${args[--remote]} ]]; then
      REMOTE="${args[--remote]}"
  fi

  git push $REMOTE $BRANCH

}

# :command.function
algo_owls_wipe_command() {
  # src/wipe_command.sh
  ini_load .algo_owls.ini

  rm -r ${ini[options.target_dir]}/*

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        algo_owls_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    build | b)
      action="build"
      shift
      algo_owls_build_parse_requirements "$@"
      shift $#
      ;;

    config | c)
      action="config"
      shift
      algo_owls_config_parse_requirements "$@"
      shift $#
      ;;

    fmt | f)
      action="fmt"
      shift
      algo_owls_fmt_parse_requirements "$@"
      shift $#
      ;;

    init | i)
      action="init"
      shift
      algo_owls_init_parse_requirements "$@"
      shift $#
      ;;

    quest | q)
      action="quest"
      shift
      algo_owls_quest_parse_requirements "$@"
      shift $#
      ;;

    run | r)
      action="run"
      shift
      algo_owls_run_parse_requirements "$@"
      shift $#
      ;;

    submit | s)
      action="submit"
      shift
      algo_owls_submit_parse_requirements "$@"
      shift $#
      ;;

    wipe | w)
      action="wipe"
      shift
      algo_owls_wipe_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      algo_owls_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
algo_owls_build_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_build_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="build"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --build_cmd | -x)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--build_cmd']="$2"
          shift
          shift
        else
          printf "%s\n" "--build_cmd requires an argument: --build_cmd, -x COMMAND" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --build_flags | -I)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--build_flags']="$2"
          shift
          shift
        else
          printf "%s\n" "--build_flags requires an argument: --build_flags, -I FLAGS" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --build_out | -o)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--build_out']="$2"
          shift
          shift
        else
          printf "%s\n" "--build_out requires an argument: --build_out, -o FLAG" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --build_sources | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--build_sources']="$2"
          shift
          shift
        else
          printf "%s\n" "--build_sources requires an argument: --build_sources, -s FLAG" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --ext | -e)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--ext']="$2"
          shift
          shift
        else
          printf "%s\n" "--ext requires an argument: --ext, -e EXTENSION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --local | -l)

        # :flag.case_no_arg
        args['--local']=1
        shift
        ;;

      # :flag.case
      --no_ext | -n)

        # :flag.case_no_arg
        args['--no_ext']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['solution']+x} ]]; then

          args['solution']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['solution']+x} ]]; then
    printf "missing required argument: SOLUTION\nusage: algo_owls build SOLUTION [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
algo_owls_config_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_config_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    get | g)
      action="get"
      shift
      algo_owls_config_get_parse_requirements "$@"
      shift $#
      ;;

    list | l)
      action="list"
      shift
      algo_owls_config_list_parse_requirements "$@"
      shift $#
      ;;

    set | s)
      action="set"
      shift
      algo_owls_config_set_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      algo_owls_config_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
algo_owls_config_get_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_config_get_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="config get"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['key']+x} ]]; then

          args['key']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['key']+x} ]]; then
    printf "missing required argument: KEY\nusage: algo_owls config get KEY\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
algo_owls_config_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_config_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="config list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
algo_owls_config_set_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_config_set_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="config set"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['key']+x} ]]; then

          args['key']=$1
          shift
        elif [[ -z ${args['value']+x} ]]; then

          args['value']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['key']+x} ]]; then
    printf "missing required argument: KEY\nusage: algo_owls config set KEY VALUE\n" >&2
    exit 1
  fi
  if [[ -z ${args['value']+x} ]]; then
    printf "missing required argument: VALUE\nusage: algo_owls config set KEY VALUE\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
algo_owls_fmt_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_fmt_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="fmt"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --fmt_cmd | -x)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--fmt_cmd']="$2"
          shift
          shift
        else
          printf "%s\n" "--fmt_cmd requires an argument: --fmt_cmd, -x COMMAND" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --fmt_flags | -I)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--fmt_flags']="$2"
          shift
          shift
        else
          printf "%s\n" "--fmt_flags requires an argument: --fmt_flags, -I FLAGS" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --ext | -e)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--ext']="$2"
          shift
          shift
        else
          printf "%s\n" "--ext requires an argument: --ext, -e EXTENSION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --no_ext | -n)

        # :flag.case_no_arg
        args['--no_ext']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['solution']+x} ]]; then

          args['solution']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['solution']+x} ]]; then
    printf "missing required argument: SOLUTION\nusage: algo_owls fmt SOLUTION [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
algo_owls_init_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_init_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="init"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --ext | -e)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--ext']="$2"
          shift
          shift
        else
          printf "%s\n" "--ext requires an argument: --ext, -e EXTENSION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --no_ext | -n)

        # :flag.case_no_arg
        args['--no_ext']=1
        shift
        ;;

      # :flag.case
      --template | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--template']="$2"
          shift
          shift
        else
          printf "%s\n" "--template requires an argument: --template, -t TEMPLATE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --touch | -o)

        # :flag.case_no_arg
        args['--touch']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['solution']+x} ]]; then

          args['solution']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['solution']+x} ]]; then
    printf "missing required argument: SOLUTION\nusage: algo_owls init SOLUTION [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
algo_owls_quest_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_quest_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="quest"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --ext | -e)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--ext']="$2"
          shift
          shift
        else
          printf "%s\n" "--ext requires an argument: --ext, -e EXTENSION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --local | -l)

        # :flag.case_no_arg
        args['--local']=1
        shift
        ;;

      # :flag.case
      --no_ext | -n)

        # :flag.case_no_arg
        args['--no_ext']=1
        shift
        ;;

      # :flag.case
      --use_source | -u)

        # :flag.case_no_arg
        args['--use_source']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['solution']+x} ]]; then

          args['solution']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['solution']+x} ]]; then
    printf "missing required argument: SOLUTION\nusage: algo_owls quest SOLUTION [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
algo_owls_run_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_run_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="run"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --build | -b)

        # :flag.case_no_arg
        args['--build']=1
        shift
        ;;

      # :flag.case
      --ext | -e)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--ext']="$2"
          shift
          shift
        else
          printf "%s\n" "--ext requires an argument: --ext, -e EXTENSION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --local | -l)

        # :flag.case_no_arg
        args['--local']=1
        shift
        ;;

      # :flag.case
      --no_ext | -n)

        # :flag.case_no_arg
        args['--no_ext']=1
        shift
        ;;

      # :flag.case
      --run_cmd | -x)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--run_cmd']="$2"
          shift
          shift
        else
          printf "%s\n" "--run_cmd requires an argument: --run_cmd, -x COMMAND" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --run_flags | -I)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--run_flags']="$2"
          shift
          shift
        else
          printf "%s\n" "--run_flags requires an argument: --run_flags, -I FLAGS" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --run_sources | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--run_sources']="$2"
          shift
          shift
        else
          printf "%s\n" "--run_sources requires an argument: --run_sources, -s FLAG" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --use_source | -u)

        # :flag.case_no_arg
        args['--use_source']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['solution']+x} ]]; then

          args['solution']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['solution']+x} ]]; then
    printf "missing required argument: SOLUTION\nusage: algo_owls run SOLUTION [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
algo_owls_submit_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_submit_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="submit"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --branch | -b)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--branch']="$2"
          shift
          shift
        else
          printf "%s\n" "--branch requires an argument: --branch, -b BRANCH" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --ext | -e)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--ext']="$2"
          shift
          shift
        else
          printf "%s\n" "--ext requires an argument: --ext, -e EXTENSION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --fmt | -p)

        # :flag.case_no_arg
        args['--fmt']=1
        shift
        ;;

      # :flag.case
      --message | -m)

        # :flag.case_no_arg
        args['--message']=1
        shift
        ;;

      # :flag.case
      --no_ext | -n)

        # :flag.case_no_arg
        args['--no_ext']=1
        shift
        ;;

      # :flag.case
      --remote | -r)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--remote']="$2"
          shift
          shift
        else
          printf "%s\n" "--remote requires an argument: --remote, -r REMOTE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['solution']+x} ]]; then

          args['solution']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['solution']+x} ]]; then
    printf "missing required argument: SOLUTION\nusage: algo_owls submit SOLUTION [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
algo_owls_wipe_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_wipe_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="wipe"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  version="0.2.0"
  long_usage=''
  set -e

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "build") algo_owls_build_command ;;
    "config") algo_owls_config_command ;;
    "config get") algo_owls_config_get_command ;;
    "config list") algo_owls_config_list_command ;;
    "config set") algo_owls_config_set_command ;;
    "fmt") algo_owls_fmt_command ;;
    "init") algo_owls_init_command ;;
    "quest") algo_owls_quest_command ;;
    "run") algo_owls_run_command ;;
    "submit") algo_owls_submit_command ;;
    "wipe") algo_owls_wipe_command ;;
  esac
}

initialize
run "$@"
