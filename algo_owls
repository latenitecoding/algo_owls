#!/usr/bin/env bash
# This script was generated by bashly 1.1.0 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
algo_owls_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls - Use to create, execute, and test solutions to competitive programming problems\n"
    echo

  else
    printf "algo_owls - Use to create, execute, and test solutions to competitive programming problems\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  algo_owls COMMAND\n"
  printf "  algo_owls [COMMAND] --help | -h\n"
  printf "  algo_owls --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Compile target solution from the 'options.solutions_dir' directory\n" "build "
  printf "  %s   Manage the algo_owls config file\n" "config"
  printf "  %s   Download test cases for target solution to the 'options.tests_dir' directory\n" "fetch "
  printf "  %s   Format the target solution from the 'options.solutions_dir' directory\n" "fmt   "
  printf "  %s   Create solution file from a template (if desired)\n" "init  "
  printf "  %s   Run target solution against each input file in 'options.test_dir' comparing results to adjacent answers\n" "quest "
  printf "  %s   Run target program\n" "run   "
  printf "  %s   Commits and pushes target solution using git\n" "submit"
  printf "  %s   Wipes all files from the 'options.target_dir' and/or 'options.tests_dir'\n" "wipe  "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
algo_owls_build_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls build - Compile target solution from the 'options.solutions_dir' directory\n"
    echo

  else
    printf "algo_owls build - Compile target solution from the 'options.solutions_dir' directory\n"
    echo

  fi

  printf "Alias: b\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls build SOLUTION [OPTIONS]\n"
  printf "  algo_owls build --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--build-cmd, -x COMMAND"
    printf "    The build command to compile the program\n"
    echo

    # :flag.usage
    printf "  %s\n" "--build-flags, -I FLAGS"
    printf "    The compiler flags to use when compiling the program\n"
    echo

    # :flag.usage
    printf "  %s\n" "--build-out, -o FLAG"
    printf "    The compiler flag to specify the output directory\n"
    echo

    # :flag.usage
    printf "  %s\n" "--build-sources, -s FLAG"
    printf "    The compiler flag to include sources in the build\n"
    echo

    # :flag.usage
    printf "  %s\n" "--ext, -e EXTENSION"
    printf "    The file extension to use for the solution file\n"
    echo

    # :flag.usage
    printf "  %s\n" "--local, -l"
    printf "    Use target solution's local directory in build source\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no-ext, -n"
    printf "    Ignore file extensions when compiling the program\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SOLUTION"
    printf "    The name of the target solution in the 'options.solutions_dir' directory\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  algo_owls build fadingwind\n"
    printf "  algo_owls build streetsahead --ext .java --build-cmd javac --build-out \"-d\n  options.target_dir\" --build-sources \"-cp options.solutions_dir\"\n"
    printf "  algo_owls build restaurantopening --ext .java --build-cmd javac --build-out\n  \"-d options.target_dir\" --build-sources \"-cp ...\" --local\n"
    echo

  fi
}

# :command.usage
algo_owls_config_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls config - Manage the algo_owls config file\n"
    echo

  else
    printf "algo_owls config - Manage the algo_owls config file\n"
    echo

  fi

  printf "Alias: c\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls config COMMAND\n"
  printf "  algo_owls config [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Remove values from the config file\n" "del "
  printf "  %s   Read a value from the config file\n" "get "
  printf "  %s   Show entire config file\n" "list"
  printf "  %s   Save a value in the config file\n" "set "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
algo_owls_config_del_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls config del - Remove values from the config file\n"
    echo

  else
    printf "algo_owls config del - Remove values from the config file\n"
    echo

  fi

  printf "Alias: d\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls config del KEY...\n"
  printf "  algo_owls config del --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "KEY..."
    printf "    One or more config keys\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  algo_owls config del user.name\n"
    printf "  algo_owls config del user.email user.password\n"
    echo

  fi
}

# :command.usage
algo_owls_config_get_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls config get - Read a value from the config file\n"
    echo

  else
    printf "algo_owls config get - Read a value from the config file\n"
    echo

  fi

  printf "Alias: g\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls config get KEY...\n"
  printf "  algo_owls config get --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "KEY..."
    printf "    One or more config keys\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  algo_owls config get TODO\n"
    echo

  fi
}

# :command.usage
algo_owls_config_list_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls config list - Show entire config file\n"
    echo

  else
    printf "algo_owls config list - Show entire config file\n"
    echo

  fi

  printf "Alias: l\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls config list [OPTIONS]\n"
  printf "  algo_owls config list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--include-tests, -t"
    printf "    Show links for known test cases\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  algo_owls config list\n"
    printf "  algo_owls config list --include-tests\n"
    echo

  fi
}

# :command.usage
algo_owls_config_set_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls config set - Save a value in the config file\n"
    echo

  else
    printf "algo_owls config set - Save a value in the config file\n"
    echo

  fi

  printf "Alias: s\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls config set ENTRY...\n"
  printf "  algo_owls config set --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "ENTRY..."
    printf "    One or more config key-value pairs\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  algo_owls config set build.cmd=javac\n"
    printf "  algo_owls config set build_flags.encoding=\"--encoding UTF-8\"\n  build_flags.out=\"-d options.target_dir\"\n"
    echo

  fi
}

# :command.usage
algo_owls_fetch_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls fetch - Download test cases for target solution to the 'options.tests_dir' directory\n"
    echo

  else
    printf "algo_owls fetch - Download test cases for target solution to the 'options.tests_dir' directory\n"
    echo

  fi

  printf "Alias: d\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls fetch SOLUTION [OPTIONS]\n"
  printf "  algo_owls fetch --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--addr, -s ADDRESS"
    printf "    The address of the input test cases and provided answers\n"
    echo

    # :flag.usage
    printf "  %s\n" "--ans-ext, -a EXTENSION"
    printf "    The file extension of the provided answers\n"
    echo

    # :flag.usage
    printf "  %s\n" "--in-ext, -i EXTENSION"
    printf "    The file extension of the input test cases\n"
    echo

    # :flag.usage
    printf "  %s\n" "--map-ans, -A EXTENSION"
    printf "    The desired file extension of the provided answers\n"
    echo

    # :flag.usage
    printf "  %s\n" "--map-in, -I EXTENSION"
    printf "    The desired file extension of the input test cases\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no-unzip, -n"
    printf "    Download data into 'options.tests_dir' directory without unzipping\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SOLUTION"
    printf "    The name of the target solution in the 'options.solutions_dir' directory\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  algo_owls fetch FadingWind\n"
    printf "  algo_owls fetch streets_ahead\n"
    printf "  algo_owls fetch color_tubes --no-unzip\n"
    echo

  fi
}

# :command.usage
algo_owls_fmt_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls fmt - Format the target solution from the 'options.solutions_dir' directory\n"
    echo

  else
    printf "algo_owls fmt - Format the target solution from the 'options.solutions_dir' directory\n"
    echo

  fi

  printf "Alias: f\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls fmt SOLUTION [OPTIONS]\n"
  printf "  algo_owls fmt --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--fmt-cmd, -x COMMAND"
    printf "    The command to format the target solution\n"
    echo

    # :flag.usage
    printf "  %s\n" "--fmt-flags, -I FLAGS"
    printf "    The flags to use when formatting the target solution\n"
    echo

    # :flag.usage
    printf "  %s\n" "--ext, -e EXTENSION"
    printf "    The file extension to use for the solution file\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no-ext, -n"
    printf "    Ignore file extensions when formatting the program\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SOLUTION"
    printf "    The name of the target solution in the 'options.solutions_dir' directory\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  algo_owls fmt fadingwind\n"
    printf "  algo_owls fmt streetsahead --ext .java --fmt-cmd \"java -jar\n  lib/google-java-format.jar\" --fmt-flags \"--replace --skip-javadoc-formatting\"\n"
    echo

  fi
}

# :command.usage
algo_owls_init_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls init - Create solution file from a template (if desired)\n"
    echo

  else
    printf "algo_owls init - Create solution file from a template (if desired)\n"
    echo

  fi

  printf "Alias: i\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls init SOLUTION [OPTIONS]\n"
  printf "  algo_owls init --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--ext, -e EXTENSION"
    printf "    The file extension to use for the solution and template files\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no-ext, -n"
    printf "    Ignore file extensions when initializing the solution file\n"
    echo

    # :flag.usage
    printf "  %s\n" "--overwrite, -o"
    printf "    Overwrite target solution if it exists\n"
    echo

    # :flag.usage
    printf "  %s\n" "--template, -t TEMPLATE"
    printf "    The path to the target template relative to the CWD\n"
    echo

    # :flag.usage
    printf "  %s\n" "--touch, -c"
    printf "    Create a blank solution instead of copying from a template file\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SOLUTION"
    printf "    The path to the target solution relative to the 'options.solutions_dir'\n    directory\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  algo_owls init fadingwind\n"
    printf "  algo_owls init streetsahead --ext .java\n"
    printf "  algo_owls init restaurantopening --ext .java --template\n  ./solutions/streetsahead\n"
    printf "  algo_owls init huntthewumpus --touch\n"
    echo

  fi
}

# :command.usage
algo_owls_quest_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls quest - Run target solution against each input file in 'options.test_dir' comparing results to adjacent answers\n"
    echo

  else
    printf "algo_owls quest - Run target solution against each input file in 'options.test_dir' comparing results to adjacent answers\n"
    echo

  fi

  printf "Alias: q\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls quest SOLUTION [OPTIONS]\n"
  printf "  algo_owls quest --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--all"
    printf "    Run all tests regardless of failures\n"
    echo

    # :flag.usage
    printf "  %s\n" "--ans-ext, -a EXTENSION"
    printf "    The file extension of the provided answers\n"
    echo

    # :flag.usage
    printf "  %s\n" "--build, -b"
    printf "    Execute the default build command prior to questing the target program\n"
    echo

    # :flag.usage
    printf "  %s\n" "--ext, -e EXTENSION"
    printf "    The file extension to use for the target solution\n"
    echo

    # :flag.usage
    printf "  %s\n" "--in-ext, -i EXTENSION"
    printf "    The file extension of the input test cases\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no-build, -d"
    printf "    Ignore the default build command prior to questing the target program\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no-ext, -n"
    printf "    Ignore extensions when questing the target solution\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SOLUTION"
    printf "    The name of the target solution from the 'options.solutions_dir' directory\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  algo_owls quest fadingwind\n"
    printf "  algo_owls quest streetsahead -ext .class\n"
    printf "  algo_owls quest restaurantopening --in-ext .in --ans-ext .ans\n"
    printf "  algo_owls quest huntthewumpus --all\n"
    echo

  fi
}

# :command.usage
algo_owls_run_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls run - Run target program\n"
    echo

  else
    printf "algo_owls run - Run target program\n"
    echo

  fi

  printf "Alias: r\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls run SOLUTION [OPTIONS]\n"
  printf "  algo_owls run --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--build, -b"
    printf "    Execute the default build command prior to running the target program\n"
    echo

    # :flag.usage
    printf "  %s\n" "--ext, -e EXTENSION"
    printf "    The file extension to use for the target program\n"
    echo

    # :flag.usage
    printf "  %s\n" "--local, -l"
    printf "    Use the target program's local directory from 'options.target_dir' in the\n    runtime source\n"
    echo

    # :flag.usage
    printf "  %s\n" "--name-only, -N"
    printf "    Use only the target program's name when executing the program\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no-build, -d"
    printf "    Ignore the default build command prior to running the target program\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no-ext, -n"
    printf "    Ignore extensions when executing the target program\n"
    echo

    # :flag.usage
    printf "  %s\n" "--quiet, -q"
    printf "    Suppress all output from algo_owls when executing the target program\n"
    echo

    # :flag.usage
    printf "  %s\n" "--run-cmd, -x COMMAND"
    printf "    The run command to use to execute the program\n"
    echo

    # :flag.usage
    printf "  %s\n" "--run-flags, -I FLAGS"
    printf "    The runtime flags to use when executing the program\n"
    echo

    # :flag.usage
    printf "  %s\n" "--run-sources, -s FLAG"
    printf "    The runtime flag to include sources in the execution\n"
    echo

    # :flag.usage
    printf "  %s\n" "--use-source, -u"
    printf "    Use the target program's local directory from 'options.solutions_dir' in the\n    runtime source\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SOLUTION"
    printf "    The name of the target program from the 'options.solutions_dir' directory\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  algo_owls run fadingwind\n"
    printf "  algo_owls run streetsahead --ext .class --run-cmd java --run-flags\n  \"-XX:+UseSerialGC\" --run-sources \"-cp options.target_dir\"\n"
    printf "  algo_owls run restaurantopening --ext .class --run-cmd java --run-flags\n  \"-XX:+UseSerialGC\" --run-sources \"-cp ...\" --local\n"
    printf "  algo_owls run huntthewumpus --ext .py --run-cmd python3 --use-source\n"
    printf "  algo_owls run colortubes --quiet\n"
    echo

  fi
}

# :command.usage
algo_owls_submit_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls submit - Commits and pushes target solution using git\n"
    echo

  else
    printf "algo_owls submit - Commits and pushes target solution using git\n"
    echo

  fi

  printf "Alias: s\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls submit SOLUTION [OPTIONS]\n"
  printf "  algo_owls submit --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--branch, -b BRANCH"
    printf "    The branch to commit to\n"
    echo

    # :flag.usage
    printf "  %s\n" "--ext, -e EXTENSION"
    printf "    The file extension to use for the solution\n"
    echo

    # :flag.usage
    printf "  %s\n" "--fmt, -p"
    printf "    Apply default formatting to target solution before committing\n"
    echo

    # :flag.usage
    printf "  %s\n" "--message, -m MESSAGE"
    printf "    Provide custom commit message\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no-ext, -n"
    printf "    Ignore extensions when executing the target solution\n"
    echo

    # :flag.usage
    printf "  %s\n" "--no-fmt, -q"
    printf "    Ignore any formatting of target solution before committing\n"
    echo

    # :flag.usage
    printf "  %s\n" "--remote, -r REMOTE"
    printf "    The remote to push to\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SOLUTION"
    printf "    The name of the target solution from the 'options.solutions_dir' directory\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  algo_owls submit fadingwind\n"
    printf "  algo_owls submit streetsahead --ext .java --branch hotjava --remote origin\n"
    printf "  algo_owls submit restaurantopening --ext .java --fmt\n"
    echo

  fi
}

# :command.usage
algo_owls_wipe_usage() {
  if [[ -n $long_usage ]]; then
    printf "algo_owls wipe - Wipes all files from the 'options.target_dir' and/or 'options.tests_dir'\n"
    echo

  else
    printf "algo_owls wipe - Wipes all files from the 'options.target_dir' and/or 'options.tests_dir'\n"
    echo

  fi

  printf "Alias: w\n"
  echo

  printf "%s\n" "Usage:"
  printf "  algo_owls wipe [OPTIONS]\n"
  printf "  algo_owls wipe --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--all, -a"
    printf "    Wipes all files from the 'options.target_dir' and 'options.tests_dir'\n"
    echo

    # :flag.usage
    printf "  %s\n" "--tests, -t"
    printf "    Wipes only the files from the 'options.tests_dir'\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  algo_owls wipe\n"
    printf "  algo_owls wipe --tests\n"
    printf "  algo_owls wipe --all\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do echo "- \${deps[$k]} = ${deps[$k]}"; done
  fi

}

# :command.user_lib
# src/lib/dot_file_ext.sh
dot_file_ext() {
    file_ext="$1"

    if [[ -n $file_ext && ${file_ext:0:1} != "." ]]; then
        file_ext=".$file_ext"
    fi

    echo "$file_ext"
    return
}

# src/lib/fmt_dir.sh
fmt_dir() {
    target_dir="$1"

    if [[ ${target_dir:0:2} == "./" ]]; then
        target_dir="${target_dir:2}"
    fi

    if [[ ${target_dir: -1} != "/" ]]; then
        target_dir="$target_dir/"
    fi

    echo "$target_dir"
    return
}

# src/lib/handle_file_ext.sh
handle_file_ext() {
    local settings_ext="${ini[settings.file_ext]}"
    local settings_no_ext="${ini[settings.no_ext]}"
    local args_ext="${args[--ext]}"
    local args_no_ext="${args[--no-ext]}"

    if [[ -n $args_no_ext && $args_no_ext -eq 1 ]]; then
        echo ""
        return
    fi

    local file_ext="$settings_ext"
    if [[ -n $settings_no_ext && $settings_no_ext == true ]]; then
        file_ext=""
    fi
    if [[ -n $args_ext ]]; then
        file_ext="$args_ext"
    fi

    echo "$(dot_file_ext $file_ext)"
    return
}

# src/lib/ini.sh

ini_load() {
  declare -gA ini

  local ini_file="$1"

  local section=""
  local key=""
  local value=""
  local section_regex="^\[(.+)\]"
  local key_regex="^([^ =]+) *= *(.*) *$"
  local comment_regex="^;"

  while IFS= read -r line; do
    if [[ $line =~ $comment_regex ]]; then
      continue
    elif [[ $line =~ $section_regex ]]; then
      section="${BASH_REMATCH[1]}."
    elif [[ $line =~ $key_regex ]]; then
      key="${BASH_REMATCH[1]}"
      value="${BASH_REMATCH[2]}"
      ini["${section}${key}"]="$value"
    fi
  done <"$ini_file"
}

ini_save() {
  declare -gA ini

  local ini_file="$1"

  local current_section=""
  local has_free_keys=false

  rm -f "$ini_file"

  for key in $(ini_keys); do
    [[ $key == *.* ]] && continue
    has_free_keys=true
    value="${ini[$key]}"
    echo "$key = $value" >>"$ini_file"
  done

  [[ "${has_free_keys}" == "true" ]] && echo >>"$ini_file"

  for key in $(ini_keys); do
    [[ $key == *.* ]] || continue
    value="${ini[$key]}"
    IFS="." read -r section_name key_name <<<"$key"

    if [[ "$current_section" != "$section_name" ]]; then
      [[ $current_section ]] && echo >>"$ini_file"
      echo "[$section_name]" >>"$ini_file"
      current_section="$section_name"
    fi

    echo "$key_name = $value" >>"$ini_file"
  done
}

ini_show() {
  declare -gA ini

  for key in $(ini_keys); do
    echo "$key = ${ini[$key]}"
  done
}

ini_keys() {
  declare -gA ini

  local keys=("${!ini[@]}")
  for a in "${keys[@]}"; do echo "$a"; done | sort
}

# src/lib/to_snake_case.sh
to_snake_case() {
    snake_case="$(echo $1 | sed -r 's/([a-z0-9])([A-Z])/\1_\L\2/g' | sed -e 's/\(.*\)/\L\1/')"
    echo $snake_case
    return
}

# :command.command_functions
# :command.function
algo_owls_build_command() {
  # src/build_command.sh
  ini_load .algo_owls.ini

  file_ext="$(handle_file_ext)"

  solution_file="${args[solution]}"
  if [[ -n $file_ext ]]; then
      solution_file="$solution_file$file_ext"
  fi

  target_file="$(find ${ini[options.solutions_dir]} -name $solution_file)"

  if [[ -z $target_file ]]; then
      echo "algo_owls: $solution_file: No such file" 1>&2
      echo "Try using: ./algo_owls init ${args[solution]}" 1>&2
      exit 1
  fi

  build_cmd="${ini[build.cmd]}"
  if [[ -n ${args[--build-cmd]} ]]; then
      build_cmd="${args[--build-cmd]}"
  fi

  if [[ -n ${args[--build-flags]} ]]; then
      build_cmd="$build_cmd ${args[--build-flags]}"
  else
      for key in "${!ini[@]}"; do
          if [[ $key == build_flags.* ]]; then
              build_cmd="$build_cmd ${ini[$key]}"
          fi
      done
  fi

  if [[ -n ${args[--build-out]} ]]; then
      build_cmd="$build_cmd ${args[--build-out]}"
  fi

  if [[ -n ${args[--build-sources]} ]]; then
      build_sources="${args[--build-sources]}"
      if [[ -n ${args[--local]} && ${args[--local]} -eq 1 ]]; then
          target_dir="${target_file%/*}"
          build_sources="${build_sources//.../$target_dir}"
      fi
      build_cmd="$build_cmd $build_sources"
  fi

  for key in "${!ini[@]}"; do
      if [[ $key == options.* ]]; then
          build_cmd="${build_cmd//$key/${ini[$key]}}"
      fi
  done

  if [[ -z ${args[--build-sources]} && ${ini[build.local]} == true ]]; then
      target_dir="${target_file%/*}"
      build_cmd="${build_cmd//.../$target_dir}"
  fi

  build_cmd="$build_cmd $target_file"

  echo $build_cmd
  eval $build_cmd

}

# :command.function
algo_owls_config_del_command() {
  # src/config_del_command.sh
  ini_load .algo_owls.ini

  eval "keys=(${args[key]})"

  for idx in "${!keys[@]}"; do
      key="${keys[idx]}"
      unset "ini[$key]"
  done

  ini_save .algo_owls.ini

}

# :command.function
algo_owls_config_get_command() {
  # src/config_get_command.sh
  ini_load .algo_owls.ini

  eval "keys=(${args[key]})"

  for idx in "${!keys[@]}"; do
      key="${keys[idx]}"
      value="${ini[$key]}"

      if [[ -n $value ]]; then
          echo "$key = $value"
      else
          echo "algo_owls: $key: No such key" 1>&2
      fi
  done

}

# :command.function
algo_owls_config_list_command() {
  # src/config_list_command.sh
  ini_load .algo_owls.ini

  for key in $(ini_keys); do
      if [[ -n ${args[--include-tests]} && ${args[--include-tests]} -eq 1 ]]; then
          echo "$key=${ini[$key]}"
      elif [[ $key != tests.* ]]; then
          echo "$key=${ini[$key]}"
      fi
  done

}

# :command.function
algo_owls_config_set_command() {
  # src/config_set_command.sh
  ini_load .algo_owls.ini

  eval "entries=(${args[entry]})"

  for idx in "${!entries[@]}"; do
      entry="${entries[idx]}"
      key="${entry%%=*}"
      value="${entry#*=}"

      if [[ -n $value ]]; then
          ini["$key"]="$value"
      else
          echo "algo_owls: '' is not a valid value" 1>&2
      fi
  done

  ini_save .algo_owls.ini

}

# :command.function
algo_owls_fetch_command() {
  # src/fetch_command.sh
  ini_load .algo_owls.ini

  solution="$(to_snake_case ${args[solution]})"

  key="tests.$solution"
  data_file="${ini[$key]}"
  if [[ -n ${args[--addr]} ]]; then
      data_file="${args[--addr]}"
  fi

  if [[ -z $data_file ]]; then
      echo "algo_owls: ${args[solution]}: No known address" 1>&2
      echo "Try using: ./algo_owls config set $key=ADDRESS" 1>&2
      exit 1
  fi

  data_ext="${data_file##*.}"
  target_file="$(fmt_dir ${ini[options.tests_dir]})$solution.$data_ext"

  echo "curl $data_file --output $target_file"
  curl $data_file --output $target_file

  if [[ -n ${args[--no-unzip]} && ${args[--no-unzip]} -eq 1 ]]; then
      exit 0
  fi

  target_dir="$(fmt_dir ${ini[options.tests_dir]})$solution/"

  if [[ $data_ext == "zip" ]]; then
      mkdir -p $target_dir
      echo "unzip $target_file -d $target_dir"
      unzip $target_file -d $target_dir
  elif [[ $data_ext == "tgz" ]]; then
      mkdir -p $target_dir
      echo "tar xf $target_file --directory=$target_dir"
      tar xvf $target_file --directory=$target_dir
  fi

  echo "rm $target_file"
  rm $target_file

  if [[ -n ${args[--in-ext]} ]]; then
      if [[ -n ${args[--map-in]} || ${args[--in-ext]} != ${ini[settings.in_ext]} ]]; then
          file_ext="$(dot_file_ext ${args[--in-ext]})"

          for in_file in $(find $target_dir -name "*$file_ext"); do
              in_file="${in_file/\/\///}"

              out_ext="${ini[settings.in_ext]}"
              if [[ -n ${args[--map-in]} ]]; then
                  out_ext="${args[--map-in]}"
              fi
              out_ext="$(dot_file_ext $out_ext)"

              out_file="${in_file%.*}$out_ext"

              echo "mv $in_file $out_file"
              mv $in_file $out_file
          done
      fi
  fi

  if [[ -n ${args[--ans-ext]} ]]; then
      if [[ -n ${args[--map-ans]} || ${args[--ans-ext]} != ${ini[settings.ans_ext]} ]]; then
          file_ext="$(dot_file_ext ${args[--ans-ext]})"

          for ans_file in $(find $target_dir -name "*$file_ext"); do
              ans_file="${ans_file/\/\///}"

              out_ext="${ini[settings.ans_ext]}"
              if [[ -n ${args[--map-ans]} ]]; then
                  out_ext="${args[--map-ans]}"
              fi
              out_ext="$(dot_file_ext $out_ext)"

              out_file="${ans_file%.*}$out_ext"

              echo "mv $ans_file $out_file"
              mv $ans_file $out_file
          done
      fi
  fi

}

# :command.function
algo_owls_fmt_command() {
  # src/fmt_command.sh
  ini_load .algo_owls.ini

  file_ext="$(handle_file_ext)"

  solution_file="${args[solution]}"
  if [[ -n $file_ext ]]; then
      solution_file="$solution_file$file_ext"
  fi

  target_file="$(find ${ini[options.solutions_dir]} -name $solution_file)"

  if [[ -z $target_file ]]; then
      echo "algo_owls: $solution_file: No such file" 1>&2
      echo "Try using: ./algo_owls init ${args[solution]}" 1>&2
      exit 1
  fi

  fmt_cmd="${ini[fmt.cmd]}"
  if [[ -n ${args[--fmt-cmd]} ]]; then
      fmt_cmd="${args[--fmt-cmd]}"
  fi

  if [[ -n ${args[--fmt-flags]} ]]; then
      fmt_cmd="$fmt_cmd ${args[--fmt-flags]}"
  else
      for key in "${!ini[@]}"; do
          if [[ $key == fmt_flags.* ]]; then
              fmt_cmd="$fmt_cmd ${ini[$key]}"
          fi
      done
  fi

  for key in "${!ini[@]}"; do
      if [[ $key == options.* ]]; then
          fmt_cmd="${fmt_cmd//$key/${ini[$key]}}"
      fi
  done

  fmt_cmd="$fmt_cmd $target_file"

  echo "$fmt_cmd"
  eval $fmt_cmd

}

# :command.function
algo_owls_init_command() {
  # src/init_command.sh
  ini_load .algo_owls.ini

  solutions_dir="$(fmt_dir ${ini[options.solutions_dir]})"

  solution_file="${args[solution]}"
  if [[ $solution_file != $solutions_dir* ]]; then
      solution_file="$solutions_dir$solution_file"
  fi

  file_ext="$(handle_file_ext)"
  if [[ -n $file_ext ]]; then
      solution_file="$solution_file$file_ext"
  fi

  if [[ -z ${args[--overwrite]} || ${args[--overwrite]} -eq 0 ]]; then
      if [[ -f $solution_file ]]; then
          echo "algo_owls: $solution_file: File already exists" 1>&2
          echo "Try using: ./algo_owls init --overwrite ${args[solution]}" 1>&2
          exit 1
      fi
  fi

  if [[ -n ${args[--touch]} && ${args[--touch]} -eq 1 ]]; then
      echo "touch $solution_file"
      mkdir -p ${solution_file%/*}
      touch $solution_file
      exit 0
  fi

  template_file="${ini[options.template_file]}"
  if [[ -n ${args[--template]} ]]; then
      template_file="${args[--template]}"
  fi
  if [[ -n $file_ext ]]; then
      template_file="$template_file$file_ext"
  fi

  if [[ -z $template_file ]]; then
      echo "algo_owls: Cannot use '' as a template file" 1>&2
      echo "Try using: ./algo_owls init --touch ${args[solution]}" 1>&2
      exit 1
  fi

  if [[ ! -f $template_file ]]; then
      echo "algo_owls: $template_file: No such file" 1>&2
      echo "Try using: ./algo_owls init --touch ${args[solution]}" 1>&2
      exit 1
  fi

  echo "cp $template_file $solution_file"
  mkdir -p ${solution_file%/*}
  cp $template_file $solution_file

}

# :command.function
algo_owls_quest_command() {
  # src/quest_command.sh
  ini_load .algo_owls.ini

  if [[ -z ${args[--no-build]} || ${args[--no-build]} -eq 0 ]]; then
      if [[ ${ini[settings.auto_build]} == true ]]; then
          ./algo_owls build ${args[solution]}
      elif [[ -n ${args[--build]} && ${args[--build]} -eq 1 ]]; then
          ./algo_owls build ${args[solution]}
      fi
  fi

  target_name="$(to_snake_case ${args[solution]})"
  target_dir="$(find ${ini[options.tests_dir]} -type d -name $target_name)"

  if [[ -z $target_dir ]]; then
      target_dir="$(fmt_dir ${ini[options.tests_dir]})**/$target_name/"
      echo "algo_owls: $target_dir: No such directory" 1>&2
      target_dir="$(fmt_dir ${ini[options.tests_dir]})$target_name"
      echo "Try using: mkdir -p $target_dir" 1>&2
      exit 1
  fi

  file_ext="$(handle_file_ext)"

  run_cmd="./algo_owls run ${args[solution]} --quiet --no-build"
  if [[ -n ${args[--ext]} ]]; then
      run_cmd="$run_cmd --ext ${args[--ext]}"
  elif [[ -n ${args[--no-ext]} ]]; then
      run_cmd="$run_cmd --no-ext"
  fi

  in_ext="${ini[settings.in_ext]}"
  if [[ -n ${args[--in-ext]} ]]; then
      in_ext="${args[--in-ext]}"
  fi
  in_ext="$(dot_file_ext $in_ext)"

  ans_ext="${ini[settings.ans_ext]}"
  if [[ -n ${args[--ans-ext]} ]]; then
      ans_ext="${args[--ans-ext]}"
  fi
  ans_ext="$(dot_file_ext $ans_ext)"

  all_tests_pass=true
  for in_file in $(find $target_dir -name "*$in_ext"); do
      ans_file="${in_file%.*}$ans_ext"
      if diff -u --suppress-common-lines --label $ans_file --label ${args[solution]} --strip-trailing-cr -d --speed-large-files --color $ans_file <((eval $run_cmd) < $in_file); then
          echo -e "\033[0;32m$in_file aye!\033[0m"
      else
          echo -e "\033[0;31m$in_file nay!\033[0m"
          all_tests_pass=false
          if [[ -z ${args[--all]} || ${args[--all]} -eq 0 ]]; then
              break
          fi
      fi
  done

  echo ""

  if [[ $all_tests_pass == true ]]; then
      echo -e "\033[0;32m${args[solution]} passes!\033[0m"
  else
      echo -e "\033[0;31m${args[solution]} vetoed!\033[0m"
  fi

}

# :command.function
algo_owls_run_command() {
  # src/run_command.sh
  ini_load .algo_owls.ini

  if [[ -z ${args[--no-build]} || ${args[--no-build]} -eq 0 ]]; then
      if [[ ${ini[settings.auto_build]} == true ]]; then
          ./algo_owls build ${args[solution]}
      elif [[ -n ${args[--build]} && ${args[--build]} -eq 1 ]]; then
          ./algo_owls build ${args[solution]}
      fi
  fi

  file_ext="$(handle_file_ext)"

  solution_file="${args[solution]}"
  if [[ -n $file_ext && -n ${args[--ext]} ]]; then
      solution_file="$solution_file$file_ext"
  elif [[ -z ${args[--no-ext]} || ${args[--no-ext]} -eq 0 ]]; then
      if [[ ${ini[run.file_ext]} != false ]]; then
          file_ext="$(dot_file_ext ${ini[run.file_ext]})"
      fi
      if [[ -n $file_ext && ${ini[run.no_ext]} == false ]]; then
          solution_file="$solution_file$file_ext"
      fi
  fi

  if [[ -n ${args[--use-source]} && ${args[--use-source]} -eq 1 ]]; then
      target_file="$(find ${ini[options.solutions_dir]} -name $solution_file)"
  else
      target_file="$(find ${ini[options.target_dir]} -name $solution_file)"
  fi

  if [[ -z $target_file ]]; then
      echo "algo_owls: $solution_file: No such file" 1>&2
      echo "Try using: ./algo_owls init ${args[solution]}" 1>&2
      exit 1
  fi

  run_cmd="${ini[run.cmd]}"
  if [[ -n ${args[--run-cmd]} ]]; then
      run_cmd="${args[--run-cmd]}"
  fi

  if [[ -n ${args[--run-flags]} ]]; then
      run_cmd="$run_cmd ${args[--run-flags]}"
  else
      for key in "${!ini[@]}"; do
          if [[ $key == run_flags.* ]]; then
              run_cmd="$run_cmd ${ini[$key]}"
          fi
      done
  fi

  if [[ -n ${args[--run-sources]} ]]; then
      run_sources="${args[--run-sources]}"
      if [[ -n ${args[--local]} && ${args[--local]} -eq 1 ]]; then
          target_dir="${target_file%/*}"
          run_sources="${run_sources//.../$target_dir}"
      elif [[ -n ${args[--use-source]} && ${args[--use-source]} -eq 1 ]]; then
          target_dir="${target_file%/*}"
          run_sources="${run_sources//.../$target_dir}"
      fi
      run_cmd="$run_cmd $run_sources"
  fi

  for key in "${!ini[@]}"; do
      if [[ $key == options.* ]]; then
          run_cmd="${run_cmd//$key/${ini[$key]}}"
      fi
  done

  if [[ ${ini[run.local]} == true ]]; then
      target_dir="${target_file%/*}"
      run_cmd="${run_cmd//.../$target_dir}"
  elif [[ ${ini[run.use_source]} == true ]]; then
      target_dir="${target_file%/*}"
      run_cmd="${run_cmd//.../$target_dir}"
  fi

  if [[ -n ${args[--name-only]} && ${args[--name-only]} -eq 1 ]]; then
      target_file="${args[solution]}"
  elif [[ ${ini[run.name_only]} == true ]]; then
      target_file="${args[solution]}"
  fi

  run_cmd="$run_cmd $target_file"

  if [[ -z ${args[--quiet]} || ${args[--quiet]} -eq 0 ]]; then
      echo $run_cmd
  fi

  eval $run_cmd

}

# :command.function
algo_owls_submit_command() {
  # src/submit_command.sh
  ini_load .algo_owls.ini

  file_ext="$(handle_file_ext)"

  solution_file="${args[solution]}"
  if [[ -n $file_ext ]]; then
      solution_file="$solution_file$file_ext"
  fi

  target_file="$(find ${ini[options.solutions_dir]} -name $solution_file)"

  if [[ -z $target_file ]]; then
      echo "algo_owls: $solution_file: No such file" 1>&2
      echo "Try using: ./algo_owls init ${args[soluton]}" 1>&2
      exit 1
  fi

  if [[ -z ${args[--no-fmt]} || ${args[--no-fmt]} -eq 0 ]]; then
      if [[ ${ini[settings.auto_fmt]} == true ]]; then
          ./algo_owls fmt ${args[solution]}
      elif [[ -n ${args[--fmt]} && ${args[--fmt]} -eq 1 ]]; then
          ./algo_owls fmt ${args[solution]}
      fi
  fi

  echo "git add $target_file"
  git add $target_file

  commit_message="completes ${args[solution]}"
  if [[ -n ${args[--message]} ]]; then
      commit_message="${args[--message]}"
  fi

  echo "git commit -m \"$commit_message\""
  git commit -m "$commit_message"

  branch="${ini[git.branch]}"
  if [[ -n ${args[--branch]} ]]; then
      branch="${args[--branch]}"
  fi

  remote="${ini[git.remote]}"
  if [[ -n ${args[--remote]} ]]; then
      remote="${args[--remote]}"
  fi

  echo "git push $remote $branch"
  git push $remote $branch

}

# :command.function
algo_owls_wipe_command() {
  # src/wipe_command.sh
  ini_load .algo_owls.ini

  if [[ -z ${args[--tests]} || ${args[--tests]} -eq 0 ]]; then
      if [[ $(ls ${ini[options.target_dir]}) ]]; then
          echo "rm -r $(fmt_dir ${ini[options.target_dir]})*"
          rm -r $(fmt_dir ${ini[options.target_dir]})*
      fi
  fi

  if [[ -n ${args[--tests]} && ${args[--tests]} -eq 1 ]]; then
      if [[ $(ls ${ini[options.tests_dir]}) ]]; then
          echo "rm -r $(fmt_dir ${ini[options.tests_dir]})*"
          rm -r $(fmt_dir ${ini[options.tests_dir]})*
      fi
  elif [[ -n ${args[--all]} && ${args[--all]} -eq 1 ]]; then
      if [[ $(ls ${ini[options.tests_dir]}) ]]; then
          echo "rm -r $(fmt_dir ${ini[options.tests_dir]})*"
          rm -r $(fmt_dir ${ini[options.tests_dir]})*
      fi
  fi

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        algo_owls_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    build | b)
      action="build"
      shift
      algo_owls_build_parse_requirements "$@"
      shift $#
      ;;

    config | c)
      action="config"
      shift
      algo_owls_config_parse_requirements "$@"
      shift $#
      ;;

    fetch | d)
      action="fetch"
      shift
      algo_owls_fetch_parse_requirements "$@"
      shift $#
      ;;

    fmt | f)
      action="fmt"
      shift
      algo_owls_fmt_parse_requirements "$@"
      shift $#
      ;;

    init | i)
      action="init"
      shift
      algo_owls_init_parse_requirements "$@"
      shift $#
      ;;

    quest | q)
      action="quest"
      shift
      algo_owls_quest_parse_requirements "$@"
      shift $#
      ;;

    run | r)
      action="run"
      shift
      algo_owls_run_parse_requirements "$@"
      shift $#
      ;;

    submit | s)
      action="submit"
      shift
      algo_owls_submit_parse_requirements "$@"
      shift $#
      ;;

    wipe | w)
      action="wipe"
      shift
      algo_owls_wipe_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      algo_owls_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
algo_owls_build_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_build_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="build"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --build-cmd | -x)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--build-cmd']="$2"
          shift
          shift
        else
          printf "%s\n" "--build-cmd requires an argument: --build-cmd, -x COMMAND" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --build-flags | -I)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--build-flags']="$2"
          shift
          shift
        else
          printf "%s\n" "--build-flags requires an argument: --build-flags, -I FLAGS" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --build-out | -o)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--build-out']="$2"
          shift
          shift
        else
          printf "%s\n" "--build-out requires an argument: --build-out, -o FLAG" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --build-sources | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--build-sources']="$2"
          shift
          shift
        else
          printf "%s\n" "--build-sources requires an argument: --build-sources, -s FLAG" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --ext | -e)
        # :flag.conflicts
        if [[ -n "${args['--no-ext']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--no-ext" >&2
          exit 1
        fi

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--ext']="$2"
          shift
          shift
        else
          printf "%s\n" "--ext requires an argument: --ext, -e EXTENSION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --local | -l)

        # :flag.case_no_arg
        args['--local']=1
        shift
        ;;

      # :flag.case
      --no-ext | -n)
        # :flag.conflicts
        if [[ -n "${args['--ext']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--ext" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--no-ext']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['solution']+x} ]]; then

          args['solution']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['solution']+x} ]]; then
    printf "missing required argument: SOLUTION\nusage: algo_owls build SOLUTION [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
algo_owls_config_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_config_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    del | d)
      action="del"
      shift
      algo_owls_config_del_parse_requirements "$@"
      shift $#
      ;;

    get | g)
      action="get"
      shift
      algo_owls_config_get_parse_requirements "$@"
      shift $#
      ;;

    list | l)
      action="list"
      shift
      algo_owls_config_list_parse_requirements "$@"
      shift $#
      ;;

    set | s)
      action="set"
      shift
      algo_owls_config_set_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      algo_owls_config_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
algo_owls_config_del_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_config_del_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="config del"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_repeatable

        if [[ -z ${args['key']+x} ]]; then
          args['key']="\"$1\""
          shift
        else
          args['key']="${args[key]} \"$1\""
          shift
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['key']+x} ]]; then
    printf "missing required argument: KEY\nusage: algo_owls config del KEY...\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
algo_owls_config_get_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_config_get_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="config get"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_repeatable

        if [[ -z ${args['key']+x} ]]; then
          args['key']="\"$1\""
          shift
        else
          args['key']="${args[key]} \"$1\""
          shift
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['key']+x} ]]; then
    printf "missing required argument: KEY\nusage: algo_owls config get KEY...\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
algo_owls_config_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_config_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="config list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --include-tests | -t)

        # :flag.case_no_arg
        args['--include-tests']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
algo_owls_config_set_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_config_set_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="config set"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_repeatable

        if [[ -z ${args['entry']+x} ]]; then
          args['entry']="\"$1\""
          shift
        else
          args['entry']="${args[entry]} \"$1\""
          shift
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['entry']+x} ]]; then
    printf "missing required argument: ENTRY\nusage: algo_owls config set ENTRY...\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
algo_owls_fetch_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_fetch_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="fetch"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --addr | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--addr']="$2"
          shift
          shift
        else
          printf "%s\n" "--addr requires an argument: --addr, -s ADDRESS" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --ans-ext | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--ans-ext']="$2"
          shift
          shift
        else
          printf "%s\n" "--ans-ext requires an argument: --ans-ext, -a EXTENSION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --in-ext | -i)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--in-ext']="$2"
          shift
          shift
        else
          printf "%s\n" "--in-ext requires an argument: --in-ext, -i EXTENSION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --map-ans | -A)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--map-ans']="$2"
          shift
          shift
        else
          printf "%s\n" "--map-ans requires an argument: --map-ans, -A EXTENSION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --map-in | -I)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--map-in']="$2"
          shift
          shift
        else
          printf "%s\n" "--map-in requires an argument: --map-in, -I EXTENSION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --no-unzip | -n)

        # :flag.case_no_arg
        args['--no-unzip']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['solution']+x} ]]; then

          args['solution']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['solution']+x} ]]; then
    printf "missing required argument: SOLUTION\nusage: algo_owls fetch SOLUTION [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
algo_owls_fmt_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_fmt_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="fmt"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --fmt-cmd | -x)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--fmt-cmd']="$2"
          shift
          shift
        else
          printf "%s\n" "--fmt-cmd requires an argument: --fmt-cmd, -x COMMAND" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --fmt-flags | -I)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--fmt-flags']="$2"
          shift
          shift
        else
          printf "%s\n" "--fmt-flags requires an argument: --fmt-flags, -I FLAGS" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --ext | -e)
        # :flag.conflicts
        if [[ -n "${args['--no-ext']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--no-ext" >&2
          exit 1
        fi

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--ext']="$2"
          shift
          shift
        else
          printf "%s\n" "--ext requires an argument: --ext, -e EXTENSION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --no-ext | -n)
        # :flag.conflicts
        if [[ -n "${args['--ext']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--ext" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--no-ext']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['solution']+x} ]]; then

          args['solution']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['solution']+x} ]]; then
    printf "missing required argument: SOLUTION\nusage: algo_owls fmt SOLUTION [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
algo_owls_init_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_init_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="init"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --ext | -e)
        # :flag.conflicts
        if [[ -n "${args['--no-ext']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--no-ext" >&2
          exit 1
        fi

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--ext']="$2"
          shift
          shift
        else
          printf "%s\n" "--ext requires an argument: --ext, -e EXTENSION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --no-ext | -n)
        # :flag.conflicts
        if [[ -n "${args['--ext']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--ext" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--no-ext']=1
        shift
        ;;

      # :flag.case
      --overwrite | -o)

        # :flag.case_no_arg
        args['--overwrite']=1
        shift
        ;;

      # :flag.case
      --template | -t)
        # :flag.conflicts
        if [[ -n "${args['--touch']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--touch" >&2
          exit 1
        fi

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--template']="$2"
          shift
          shift
        else
          printf "%s\n" "--template requires an argument: --template, -t TEMPLATE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --touch | -c)
        # :flag.conflicts
        if [[ -n "${args['--template']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--template" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--touch']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['solution']+x} ]]; then

          args['solution']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['solution']+x} ]]; then
    printf "missing required argument: SOLUTION\nusage: algo_owls init SOLUTION [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
algo_owls_quest_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_quest_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="quest"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --all)

        # :flag.case_no_arg
        args['--all']=1
        shift
        ;;

      # :flag.case
      --ans-ext | -a)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--ans-ext']="$2"
          shift
          shift
        else
          printf "%s\n" "--ans-ext requires an argument: --ans-ext, -a EXTENSION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --build | -b)
        # :flag.conflicts
        if [[ -n "${args['--no-build']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--no-build" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--build']=1
        shift
        ;;

      # :flag.case
      --ext | -e)
        # :flag.conflicts
        if [[ -n "${args['--no-ext']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--no-ext" >&2
          exit 1
        fi

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--ext']="$2"
          shift
          shift
        else
          printf "%s\n" "--ext requires an argument: --ext, -e EXTENSION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --in-ext | -i)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--in-ext']="$2"
          shift
          shift
        else
          printf "%s\n" "--in-ext requires an argument: --in-ext, -i EXTENSION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --no-build | -d)
        # :flag.conflicts
        if [[ -n "${args['--build']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--build" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--no-build']=1
        shift
        ;;

      # :flag.case
      --no-ext | -n)
        # :flag.conflicts
        if [[ -n "${args['--ext']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--ext" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--no-ext']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['solution']+x} ]]; then

          args['solution']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['solution']+x} ]]; then
    printf "missing required argument: SOLUTION\nusage: algo_owls quest SOLUTION [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
algo_owls_run_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_run_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="run"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --build | -b)
        # :flag.conflicts
        if [[ -n "${args['--no-build']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--no-build" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--build']=1
        shift
        ;;

      # :flag.case
      --ext | -e)
        # :flag.conflicts
        if [[ -n "${args['--no-ext']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--no-ext" >&2
          exit 1
        fi

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--ext']="$2"
          shift
          shift
        else
          printf "%s\n" "--ext requires an argument: --ext, -e EXTENSION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --local | -l)
        # :flag.conflicts
        if [[ -n "${args['--use-source']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--use-source" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--local']=1
        shift
        ;;

      # :flag.case
      --name-only | -N)

        # :flag.case_no_arg
        args['--name-only']=1
        shift
        ;;

      # :flag.case
      --no-build | -d)
        # :flag.conflicts
        if [[ -n "${args['--build']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--build" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--no-build']=1
        shift
        ;;

      # :flag.case
      --no-ext | -n)
        # :flag.conflicts
        if [[ -n "${args['--ext']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--ext" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--no-ext']=1
        shift
        ;;

      # :flag.case
      --quiet | -q)

        # :flag.case_no_arg
        args['--quiet']=1
        shift
        ;;

      # :flag.case
      --run-cmd | -x)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--run-cmd']="$2"
          shift
          shift
        else
          printf "%s\n" "--run-cmd requires an argument: --run-cmd, -x COMMAND" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --run-flags | -I)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--run-flags']="$2"
          shift
          shift
        else
          printf "%s\n" "--run-flags requires an argument: --run-flags, -I FLAGS" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --run-sources | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--run-sources']="$2"
          shift
          shift
        else
          printf "%s\n" "--run-sources requires an argument: --run-sources, -s FLAG" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --use-source | -u)
        # :flag.conflicts
        if [[ -n "${args['--local']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--local" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--use-source']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['solution']+x} ]]; then

          args['solution']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['solution']+x} ]]; then
    printf "missing required argument: SOLUTION\nusage: algo_owls run SOLUTION [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
algo_owls_submit_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_submit_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="submit"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --branch | -b)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--branch']="$2"
          shift
          shift
        else
          printf "%s\n" "--branch requires an argument: --branch, -b BRANCH" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --ext | -e)
        # :flag.conflicts
        if [[ -n "${args['--no-ext']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--no-ext" >&2
          exit 1
        fi

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--ext']="$2"
          shift
          shift
        else
          printf "%s\n" "--ext requires an argument: --ext, -e EXTENSION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --fmt | -p)
        # :flag.conflicts
        if [[ -n "${args['--no-fmt']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--no-fmt" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--fmt']=1
        shift
        ;;

      # :flag.case
      --message | -m)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--message']="$2"
          shift
          shift
        else
          printf "%s\n" "--message requires an argument: --message, -m MESSAGE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --no-ext | -n)
        # :flag.conflicts
        if [[ -n "${args['--ext']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--ext" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--no-ext']=1
        shift
        ;;

      # :flag.case
      --no-fmt | -q)
        # :flag.conflicts
        if [[ -n "${args['--fmt']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--fmt" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--no-fmt']=1
        shift
        ;;

      # :flag.case
      --remote | -r)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--remote']="$2"
          shift
          shift
        else
          printf "%s\n" "--remote requires an argument: --remote, -r REMOTE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['solution']+x} ]]; then

          args['solution']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['solution']+x} ]]; then
    printf "missing required argument: SOLUTION\nusage: algo_owls submit SOLUTION [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
algo_owls_wipe_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        algo_owls_wipe_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="wipe"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --all | -a)
        # :flag.conflicts
        if [[ -n "${args['--tests']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--tests" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--all']=1
        shift
        ;;

      # :flag.case
      --tests | -t)
        # :flag.conflicts
        if [[ -n "${args['--all']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--all" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--tests']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  version="0.9.0"
  long_usage=''
  set -e

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "build") algo_owls_build_command ;;
    "config") algo_owls_config_command ;;
    "config del") algo_owls_config_del_command ;;
    "config get") algo_owls_config_get_command ;;
    "config list") algo_owls_config_list_command ;;
    "config set") algo_owls_config_set_command ;;
    "fetch") algo_owls_fetch_command ;;
    "fmt") algo_owls_fmt_command ;;
    "init") algo_owls_init_command ;;
    "quest") algo_owls_quest_command ;;
    "run") algo_owls_run_command ;;
    "submit") algo_owls_submit_command ;;
    "wipe") algo_owls_wipe_command ;;
  esac
}

initialize
run "$@"
